(module $wasi_ephemeral_crypto_signatures
  (import "memory" (memory))

  ;;; Generate a new key pair for signatures.
  ;;;
  ;;; Internally, a key pair stores the supplied algorithm and optional parameters.
  ;;;
  ;;; Trying to use that key pair with different parameters will throw an `invalid_key` error.
  ;;;
  ;;; This function may return `$crypto_errno.unsupported_feature` if key generation is not supported by the host for the chosen algorithm.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let kp_handle = ctx.signature_keypair_generate("RSA_PKCS1_2048_8192_SHA512", None)?;
  ;;; ```
  (@interface func (export "signature_keypair_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Import a key pair for signatures.
  ;;;
  ;;; This function creates a `signature_keypair` object from existing material.
  ;;;
  ;;; It may return `unsupported_algorithm` if the encoding scheme is not supported, or `invalid_key` if the key cannot be decoded.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let kp_handle = ctx.signature_keypair_import("RSA_PKCS1_2048_8192_SHA512", KeypairEncoding::PKCS8)?;
  ;;; ```
  (@interface func (export "signature_keypair_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; __(optional)__
  ;;; Return the key pair identifier and version of a managed signature key pair.
  ;;;
  ;;; If the key pair is not managed, `unsupported_feature` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_id")
    (param $kp $signature_keypair)
    (param $kp_id (@witx pointer u8))
    (param $kp_id_max_len $size)
    (result $error $crypto_errno)
    (result $kp_id_len $size)
    (result $version $version)
  )

  ;;; __(optional)__
  ;;; Return a managed signature key pair from a key identifier.
  ;;;
  ;;; `kp_version` can be set to `version_latest` to retrieve the most recent version of a key pair.
  ;;;
  ;;; If no key pair matching the provided information is found, `key_not_found` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  ;;; ```
  (@interface func (export "signature_keypair_from_id")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; __(optional)__
  ;;; Invalidate a managed key pair given a key pair identifier and a version.
  ;;;
  ;;; This asks the key manager to delete or revoke a key pair or a version of a key pair.
  ;;;
  ;;; Once this function returns, `signature_keypair_from_id` will return that key pair any longer.
  ;;;
  ;;; `kp_version` can be set to a version number, to `version.latest` to invalidate the current version, or to `version.all` to invalidate all versions of a key.
  ;;;
  ;;; The function returns `unsupported_feature` if this operation is not supported by the host, and `key_not_found` if the identifier and version don't match any existing key pair.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_invalidate")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Export a signature key pair as the given encoding format.
  ;;;
  ;;; May return `prohibited_operation` if this operation is denied or `unsupported_encoding` if the encoding is not supported.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_export")
    (param $kp $signature_keypair)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Get a public key of a signature key pair.
  ;;;
  ;;; The returned object can be used to verify signatures.
  (@interface func (export "signature_keypair_publickey")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Destroys a signature key pair.
  ;;;
  ;;; The host will automatically wipe traces of the secret key from memory.
  ;;;
  ;;; If this is a managed key, the key will not be removed from persistent storage, and can be reconstructed later using the key identifier.
  (@interface func (export "signature_keypair_close")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
  )

  ;;; Import a signature public key.
  ;;;
  ;;; The returned object can be used to verify signatures.
  ;;;
  ;;; The function may return `unsupported_encoding` if importing from the given format is not implemented or incompatible with the key type.
  ;;;
  ;;; It may also return `invalid_key` if the key doesn't appear to match the supplied algorithm.
  ;;;
  ;;; Finally, the function may return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let pk_handle = ctx.signature_publickey_import(encoded, PublicKeyEncoding::Sec)?;
  ;;; ```
  (@interface func (export "signature_publickey_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $publickey_encoding)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Check that a signature public key is valid and in canonical form.
  ;;;
  ;;; This function may perform stricter checks than those made during importation at the expense of additional CPU cycles.
  ;;;
  ;;; The function returns `invalid_key` if the public key didn't pass the checks.
  (@interface func (export "signature_publickey_verify")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Destroys a public key.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "signature_publickey_close")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Export a signature.
  ;;;
  ;;; This function exports a signature object using the specified encoding.
  ;;;
  ;;; May return `unsupported_encoding` if the signature cannot be encoded into the given format.
  (@interface func (export "signature_export")
    (param $signature $signature)
    (param $encoding $signature_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a signature object.
  ;;;
  ;;; This object can be used along with a public key to verify an existing signature.
  ;;;
  ;;; It may return `invalid_signature` if the signature is invalid or incompatible with the specified algorithm, as well as `unsupported_encoding` if the encoding is not compatible with the signature type.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let signature_handle = ctx.signature_import("ECDSA_P256_SHA256", SignatureEncoding::DER, encoded)?;
  ;;; ```
  (@interface func (export "signature_import")
    (param $algorithm string)
    (param $encoding $signature_encoding)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $signature $signature)
  )

  ;;; Create a new state to collect data to compute a signature on.
  ;;;
  ;;; This function allows data to be signed to be supplied in a streaming fashion.
  ;;;
  ;;; The state is not closed and can be used after a signature has been computed, allowing incremental updates by calling `signature_state_update()` again afterwards.
  ;;;
  ;;; Example usage - signature creation
  ;;;
  ;;; ```rust
  ;;; let kp_handle = ctx.signature_keypair_import("Ed25519ph", keypair, KeypairEncoding::Raw)?;
  ;;; let state_handle = ctx.signature_state_open(kp_handle)?;
  ;;; ctx.signature_state_update(state_handle, b"message part 1")?;
  ;;; ctx.signature_state_update(state_handle, b"message part 2")?;
  ;;; let sig_handle = ctx.signature_state_sign(state_handle)?;
  ;;; let raw_sig = ctx.signature_export(sig_handle, SignatureEncoding::Raw)?;
  ;;; ```
  (@interface func (export "signature_state_open")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $state $signature_state)
  )

  ;;; Absorb data into the signature state.
  ;;;
  ;;; This function may return `unsupported_feature` is the selected algorithm doesn't support incremental updates.
  (@interface func (export "signature_state_update")
    (param $state $signature_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute a signature for all the data collected up to that point.
  ;;;
  ;;; The function can be called multiple times for incremental signing.
  (@interface func (export "signature_state_sign")
    (param $state $signature_state)
    (result $error $crypto_errno)
    (result $signature $array_output)
  )

  ;;; Destroy a signature state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  ;;;
  ;;; Note that closing a signature state doesn't close or invalidate the key pair object, that be reused for further signatures.
  (@interface func (export "signature_state_close")
    (param $state $signature_state)
    (result $error $crypto_errno)
  )

  ;;; Create a new state to collect data to verify a signature on.
  ;;;
  ;;; This is the verification counterpart of `signature_state`.
  ;;;
  ;;; Data can be injected using `signature_verification_state_update()`, and the state is not closed after a verification, allowing incremental verification.
  ;;;
  ;;; Example usage - signature verification:
  ;;;
  ;;; ```rust
  ;;; let pk_handle = ctx.signature_publickey_import("ECDSA_P256_SHA256", encoded_pk PublicKeyEncoding::CompressedSec)?;
  ;;; let signature_handle = ctx.signature_import("ECDSA_P256_SHA256", encoded_sig, PublicKeyEncoding::Der)?;
  ;;; let state_handle = ctx.signature_verification_state_open(pk_handle)?;
  ;;; ctx.signature_verification_state_update(state_handle, "message")?;
  ;;; ctx.signature_verification_state_verify(signature_handle)?;
  ;;; ```
  (@interface func (export "signature_verification_state_open")
    (param $kp $signature_publickey)
    (result $error $crypto_errno)
    (result $state $signature_verification_state)
  )

  ;;; Absorb data into the signature verification state.
  ;;;
  ;;; This function may return `unsupported_feature` is the selected algorithm doesn't support incremental updates.
  (@interface func (export "signature_verification_state_update")
    (param $state $signature_verification_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Check that the given signature is verifies for the data collected up to that point point.
  ;;;
  ;;; The state is not closed and can absorb more data to allow for incremental verification.
  ;;;
  ;;; The function returns `invalid_signature` if the signature doesn't appear to be valid.
  (@interface func (export "signature_verification_state_verify")
    (param $state $signature_verification_state)
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature verification state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  ;;;
  ;;; Note that closing a signature state doesn't close or invalidate the public key object, that be reused for further verifications.
  (@interface func (export "signature_verification_state_close")
    (param $state $signature_verification_state)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "signature_close")
    (param $signature $signature)
    (result $error $crypto_errno)
  )
)
