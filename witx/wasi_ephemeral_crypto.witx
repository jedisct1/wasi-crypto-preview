;; WASI Cryptography API

;;; Error codes.
(typename $crypto_errno
  (enum u16
    ;;; Operation succeeded.  
    $success

    ;;; An error occurred when trying to during a conversion from a host type to a guest type.
    ;;;
    ;;; Only an internal bug can throw this error.
    $guest_error

    ;;; The requested operation is valid, but not implemented by the host.
    $not_implemented

    ;;; The requested feature is not supported by the chosen algorithm.
    $unsupported_feature

    ;;; The requested operation is valid, but was administratively prohibited.
    $prohibited_operation

    ;;; Unsupported encoding for an import or export operation.
    $unsupported_encoding

    ;;; The requested algorithm is not supported by the host.
    $unsupported_algorithm

    ;;; The requested option is not supported by the currently selected algorithm.
    $unsupported_option

    ;;; An invalid or incompatible key was supplied.
    ;;;
    ;;; The key may not be valid, or was generated for a different algorithm or parameters set.
    $invalid_key

    ;;; The currently selected algorithm doesn't support the requested output length.
    ;;;
    ;;; This error is thrown by non-extensible hash functions, when requesting an output size larger than they produce out of a single block.
    $invalid_length

    ;;; A signature or authentication tag verification failed.
    $verification_failed

    ;;; A secure random numbers generator is not available.
    ;;;
    ;;; The requested operation requires random numbers, but the host cannot securely generate them at the moment. 
    $rng_error

    ;;; An error was returned by the underlying cryptography library.
    ;;;
    ;;; The host may be running out of memory, parameters may be incompatible with the chosen implementation of an algorithm or another unexpected error may have happened.
    ;;;
    ;;; Ideally, the specification should provide enough details and guidance to make this error impossible to ever be thrown.
    ;;;
    ;;; Realistically, the WASI crypto module cannot possibly cover all possible error types implementations can return, especially since some of these may be language-specific.
    ;;; This error can thus be thrown when other error types are not suitable, and when the original error comes from the cryptographic primitives themselves and not from the WASI module.
    $algorithm_failure

    ;;; The supplied signature is invalid, or incompatible with the chosen algorithm.
    $invalid_signature

    ;;; An attempt was made to close a handle that was already closed.
    $closed

    ;;; A function was called with an unassigned handle, a closed handle, or handle of an unexpected type.
    $invalid_handle

    ;;; The host needs to copy data to a guest-allocated buffer, but that buffer is too small.
    $overflow

    ;;; An internal error occurred.
    ;;;
    ;;; This error is reserved to internal consistency checks, and must only be sent if the internal state of the host remains safe after an inconsistency was detected.
    $internal_error

    ;;; Too many handles are currently open, and a new one cannot be created.
    ;;;
    ;;; Implementations are free to represent handles as they want, and to enforce limits to limit resources usage.
    $too_many_handles

    ;;; A key was provided, but the chosen algorithm doesn't support keys.
    ;;;
    ;;; This is returned by symmetric operations.
    ;;;
    ;;; Many hash functions, in particular, do not support keys without being used in particular constructions.
    ;;; Blindly ignoring a key provided by mistake while trying to open a context for such as function could cause serious security vulnerabilities.
    ;;;
    ;;; These functions must refuse to create the context and return this error instead.
    $key_not_supported

    ;;; A key is required for the chosen algorithm, but none was given.
    $key_required

    ;;; The provided authentication tag is invalid or incompatible with the current algorithm.
    ;;;
    ;;; This error is returned by decryption functions and tag verification functions.
    ;;;
    ;;; Unlike `verification_failed`, this error code is returned when the tag cannot possibly verify for any input.
    $invalid_tag

    ;;; The requested operation is incompatible with the current scheme.
    ;;;
    ;;; For example, the `symmetric_state_encrypt()` function cannot complete if the selected construction is a key derivation function.
    ;;; This error code will be returned instead.
    $invalid_operation

    ;;; A nonce is required.
    ;;;
    ;;; Most encryption schemes require a nonce.
    ;;;
    ;;; In the absence of a nonce, the WASI cryptography module can automatically generate one, if that can be done safely. The nonce can be retrieved later with the `symmetric_state_option_get()` function using the `nonce` parameter.
    ;;; If automatically generating a nonce cannot be done safely, the module never falls back to an insecure option and requests an explicit nonce by throwing that error.
    $nonce_required

    ;;; The named option was not set.
    ;;;
    ;;; The caller tried to read the value of an option that was not set.
    ;;; This error is used to make the distinction between an empty option, and an option that was not set and left to its default value.
    $option_not_set
  )
)

;;; Encoding to use for importing or exporting a key pair.
(typename $keypair_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; PCSK8 encoding.
    $pkcs8

    ;;; DER encoding.
    $der

    ;;; PEM encoding.
    $pem
  )
)

;;; Encoding to use for importing or exporting a public key.
(typename $publickey_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; DER encoding.
    $der

    ;;; PEM encoding.
    $pem

    ;;; SEC encoding.
    $sec

    ;;; Compressed SEC encoding.
    $compressed_sec
  )
)

;;; Encoding to use for importing or exporting a signature.
(typename $signature_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; DER encoding.
    $der
  )
)

;;; Type of an options set.
;;;
;;; This is used when creating a new options set with `options_open()`.
(typename $options_type
  (enum u16
    $signatures
    $symmetric
  )
)

;;; Version of a managed key.
;;;
;;; A version can be an arbitrary `u64` integer, with the expection of some reserved values.
(typename $version
  (int u64
    ;;; Key doesn't support versioning.

    (const $unspecified 0xff00000000000000)
    ;;; Use the latest version of a key.

    (const $latest 0xff00000000000001)

    ;;; Perform an operation over all versions of a key.
    (const $all 0xff00000000000002)
  )
)

;;; Size of a value.
(typename $size (@witx usize))

;;; Handle for functions returning output whose size may be large or not known in advance.
;;;
;;; An `array_output` object contains a host-allocated byte array.
;;;
;;; A guest can get the size of that array after a function returns in order to then allocate a buffer of the correct size.
;;; In addition, the content of such an object can be consumed by a guest in a streaming fashion.
;;;
;;; An `array_output` handle is automatically closed after its full content has been consumed.
(typename $array_output (handle))

;;; A set of options.
;;;
;;; This type is used to set non-default parameters.
;;;
;;; The exact set of allowed options depends on the algorithm being used.
(typename $options (handle))

;;; A handle to the optional key management facilities offered by a host.
;;;
;;; This is used to generate, retrieve and invalidate managed signature key pairs.
(typename $signature_keypair_manager (handle))

;;; A key pair for signatures.
(typename $signature_keypair (handle))

;;; A state to absorb data to be signed.
;;;
;;; After a signature has been computed or verified, the state remains valid for further operations.
;;;
;;; A subsequent signature would sign all the data accumulated since the creation of the state object.
(typename $signature_state (handle))

;;; A signature.
(typename $signature (handle))

;;; A public key that can be used to verify a signature.
(typename $signature_publickey (handle))

;;; A state to absorb signed data to be verified.
(typename $signature_verification_state (handle))

;;; A handle to the optional key management facilities offered by a host.
;;;
;;; This is used to generate, retrieve and invalidate managed symmetric keys.
(typename $symmetric_key_manager (handle))

;;; A state to perform symmetric operations.
;;;
;;; The state is not reset nor invalidated after an option has been performed.
;;; Incremental updates and sessions are thus supported.
(typename $symmetric_state (handle))

;;; A symmetric key.
;;;
;;; The key can be imported from raw bytes, or can be a reference to a managed key.
;;;
;;; If it was imported, the host will wipe it from memory as soon as the handle is closed.
(typename $symmetric_key (handle))

;;; An authentication tag.
;;;
;;; This is an object returned by functions computing authentication tags.
;;;
;;; A tag can be compared against another tag (directly supplied as raw bytes) in constant time with the `symmetric_tag_verify()` function.
;;;
;;; This object type can't be directly created from raw bytes. They are only returned by functions computing MACs.
;;;
;;; The host is reponsible for securely wiping them from memory on close.
(typename $symmetric_tag (handle))

;;; Options index, only required by the Interface Types translation layer.
(typename $opt_options_u (enum u8 $some $none))

;;; An optional options set.
;;;
;;; This union simulates an `Option<Options>` type to make the `options` parameter of some functions optional.
(typename $opt_options (union $opt_options_u (field $some $options) (empty $none)))

;;; Symmetric key index, only required by the Interface Types translation layer.
(typename $opt_symmetric_key_u (enum u8 $some $none))

;;; An optional symmetric key.
;;;
;;; This union simulates an `Option<SymmetricKey>` type to make the `symmetric_key` parameter of some functions optional.
(typename $opt_symmetric_key (union $opt_symmetric_key_u (field $some $symmetric_key) (empty $none)))

;;; A WASI cryptography submodule proposal.
(module $wasi_ephemeral_crypto
  (import "memory" (memory))

  ;;; Create a new object to set non-default options.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let options_handle = ctx.options_open();
  ;;; ctx.options_set(options_handle, "context", context);
  ;;; ctx.options_set_u64(options_handle, "threads", 4);
  ;;; let state = ctx.symmetric_state_open("BLAKE3", None, Some(options_handle));
  ;;; ctx.options_close(options_handle);
  ;;; ```
  (@interface func (export "options_open")
    (param $options_type $options_type)
    (result $error $crypto_errno)
    (result $handle $options)
  )

  ;;; Destroy an options object.
  (@interface func (export "options_close")
    (param $handle $options)
    (result $error $crypto_errno)
  )

  ;;; Set or update an option.
  (@interface func (export "options_set")
    (param $handle $options)
    (param $name string)
    (param $value (@witx const_pointer u8))
    (param $value_len $size)
    (result $error $crypto_errno)
  )

  ;;; Set or update an integer option.
  (@interface func (export "options_set_u64")
    (param $handle $options)
    (param $name string)
    (param $value u64)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an array_output object.
  (@interface func (export "array_output_len")
    (param $array_output $array_output)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy an array_output into an application-allocated buffer.
  ;;; The array_output handle becomes invalid after this operation.
  (@interface func (export "array_output_pull")
    (param $array_output $array_output)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Create a context to the key manager.
  (@interface func (export "signature_keypair_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair_manager)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Destroy a key manager context.
  (@interface func (export "signature_keypair_manager_close")
    (param $kp_manager $signature_keypair_manager)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Generate a new managed key pair.
  ;;; This function may return `$crypto_errno.unsupported_feature` if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "signature_managed_keypair_generate")
    (param $kp_manager $signature_keypair_manager)
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Generate a new key pair.
  ;;; This function may return `$crypto_errno.unsupported_feature` if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "signature_keypair_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Import a key pair.
  ;;; This function may return `$crypto_errno.unsupported_algorithm` if the
  ;;; encoding scheme is not supported, or crypto_errno.invalid_key if the key
  ;;; cannot be decoded.
  (@interface func (export "signature_keypair_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Return the key identifier and version, if these are available
  ;;; or `$crypto_errno.unsupported_feature` if not.
  (@interface func (export "signature_keypair_id")
    (param $kp $signature_keypair)
    (param $kp_id (@witx pointer u8))
    (param $kp_id_max_len $size)
    (result $error $crypto_errno)
    (result $kp_id_len $size)
    (result $version $version)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Create a key pair using an opaque key identifier.
  ;;; Return `$crypto_errno.unsupported_feature` if this operation is not
  ;;; supported by the host, and `$crypto_errno.invalid_key` if the identifier
  ;;; is invalid.
  ;;; The version can be an actual version number or $version.latest .
  (@interface func (export "signature_keypair_from_id")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Invalidate a key pair given a key identifier and a version.
  ;;; Return `$crypto_errno.unsupported_feature` if this operation is not
  ;;; supported by the host, and `$crypto_errno.invalid_key` if the identifier
  ;;; is invalid.
  ;;; The version can be a actual version number, as well as
  ;;; `$version.latest` or `$version.all` .
  (@interface func (export "signature_keypair_invalidate")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Export the key pair as the given encoding format.
  ;;; May return `$crypto_errno.prohibited_operation` if this operation is
  ;;; not available or `$crypto_errno.unsupported_encoding` if the encoding
  ;;; is not supported.
  (@interface func (export "signature_keypair_export")
    (param $kp $signature_keypair)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a public key object from the key pair.
  (@interface func (export "signature_keypair_publickey")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Destroys a key pair and wipe memory accordingly.
  (@interface func (export "signature_keypair_close")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
  )

  ;;; Import a public key encoded.
  ;;; Return `$crypto_errno.unsupported_encoding` if exporting
  ;;; to the given format is not implemented or if the format is
  ;;; incompatible with the key type.
  (@interface func (export "signature_publickey_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $publickey_encoding)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Check that a public key is valid and in canonical form.
  ;;; Return `$crypto_errno.invalid_key` if verification fails.
  (@interface func (export "signature_publickey_verify")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Destroys a public key.
  (@interface func (export "signature_publickey_close")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Export a signature in the given format.
  (@interface func (export "signature_export")
    (param $signature $signature)
    (param $encoding $signature_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a signature object by importing a signature encoded
  ;;; in a given format.
  ;;; Return `$crypto_errno.invalid_signature` if the signature is incompatible
  ;;; with the current content.
  (@interface func (export "signature_import")
    (param $algorithm string)
    (param $encoding $signature_encoding)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $signature $signature)
  )

  ;;; Create a new state to collect data to compute a signature on.
  (@interface func (export "signature_state_open")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $state $signature_state)
  )

  ;;; Inject data into the state.
  (@interface func (export "signature_state_update")
    (param $state $signature_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute a signature for all the data collected until tht point.
  ;;; The function can be called multiple times for incremental signing.
  ;;; May return `$crypto_errno.overflow` is too much data has been processed
  ;;; for the chosen algorithm or if system resources have been
  ;;; exceeded.
  (@interface func (export "signature_state_sign")
    (param $state $signature_state)
    (result $error $crypto_errno)
    (result $signature $array_output)
  )

  ;;; Destroy a signature state.
  (@interface func (export "signature_state_close")
    (param $state $signature_state)
    (result $error $crypto_errno)
  )

  ;;; Create a new state to collect data to verify a signature on.
  (@interface func (export "signature_verification_state_update")
    (param $state $signature_verification_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Verify that the given signature is valid for the data collected
  ;;; up to this point.
  (@interface func (export "signature_verification_state_verify")
    (param $state $signature_verification_state)
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature verification state.
  (@interface func (export "signature_verification_state_close")
    (param $state $signature_verification_state)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature.
  (@interface func (export "signature_close")
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an authentication tag.
  (@interface func (export "symmetric_tag_len")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy an authentication tag into an application-allocated buffer.
  ;;; The handle becomes invalid after this operation.
  (@interface func (export "symmetric_tag_pull")
    (param $symmetric_tag $symmetric_tag)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; Verity that a computed tag matches an expected tag.
  ;;; The reference tag is an object, but the expected tag
  ;;; is a raw byte string.
  (@interface func (export "symmetric_tag_verify")
    (param $symmetric_tag $symmetric_tag)
    (param $expected_raw_tag_ptr (@witx const_pointer u8))
    (param $expected_raw_tag_len $size)
    (result $error $crypto_errno)
  )

  ;;; Destroy an authentication tag.
  (@interface func (export "symmetric_tag_close")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
  )

  ;;; Generate a new symmetric key.
  ;;; This function may return `$crypto_errno.unsupported_feature` if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "symmetric_key_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Import a symmetric key.
  (@interface func (export "symmetric_key_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Destroys a symmetric key.
  (@interface func (export "symmetric_key_close")
    (param $symmetric_key $symmetric_key)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Create a context to access a key manager.
  (@interface func (export "symmetric_key_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key_manager)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Destroy a key manager.
  (@interface func (export "symmetric_key_manager_close")
    (param $symmetric_key_manager $symmetric_key_manager)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Return the symmetric key identifier and version, if these are available
  ;;; or `$crypto_errno.unsupported_feature` if not.
  (@interface func (export "symmetric_key_id")
    (param $symmetric_key $symmetric_key)
    (param $symmetric_key_id (@witx pointer u8))
    (param $symmetric_key_id_max_len $size)
    (result $error $crypto_errno)
    (result $symmetric_key_id_len $size)
    (result $version $version)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Generate a new managed symmetric key.
  ;;; This function may return `$crypto_errno.unsupported_feature` if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "symmetric_managed_key_generate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Create a symmetric key using an opaque key identifier.
  ;;; Return `$crypto_errno.unsupported_feature` if this operation is not
  ;;; supported by the host, and crypto_errno.invalid_key if the identifier
  ;;; is invalid.
  ;;; The version can be an actual version number or `$version.latest`.
  (@interface func (export "symmetric_key_from_id")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Invalidate a symmetric key given a key identifier and a version.
  ;;; Return `$crypto_errno.unsupported_feature` if this operation is not
  ;;; supported by the host, and `$crypto_errno.invalid_key` if the identifier
  ;;; is invalid.
  ;;; The version can be a actual version number, as well as
  ;;; `$version.latest` or `$version.all`.
  (@interface func (export "symmetric_key_invalidate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
  )

  ;;; Retrieve a parameter from the current state.
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used
  ;;; to get a nonce that as automatically generated.
  (@interface func (export "symmetric_state_open")
    (param $alg_str string)
    (param $key $opt_symmetric_key)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $symmetric_state $symmetric_state)
  )

  ;;; Retrieve a parameter from the current state.
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used
  ;;; to get a nonce that as automatically generated.
  (@interface func (export "symmetric_state_options_get")
    (param $handle $symmetric_state)
    (param $name string)
    (param $value (@witx pointer u8))
    (param $value_max_len $size)
    (result $error $crypto_errno)
    (result $value_len $size)
  )

  ;;; Retrieve an integer parameter from the current state.
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used
  ;;; to get a nonce that as automatically generated.
  (@interface func (export "symmetric_state_options_get_u64")
    (param $handle $symmetric_state)
    (param $name string)
    (result $error $crypto_errno)
    (result $value u64)
  )

  ;;; Destroy a symmetric state.
  (@interface func (export "symmetric_state_close")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )

  ;;; Absorb data into the state.
  ;;; This can be data to be hashed for a hash function,
  ;;; or additional data for an AEAD.
  (@interface func (export "symmetric_state_absorb")
    (param $handle $symmetric_state)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
  )

  ;;; Squeeze bytes from the state.
  ;;; This can be the output of a hash function (with limits on
  ;;; the output length), a XOF, a stream cipher or a KDF.
  (@interface func (export "symmetric_state_squeeze")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute and return a tag for all the data injected into
  ;;; the state so far. This can be a MAC or a self-contained
  ;;; verification tag for a password hashing function.
  (@interface func (export "symmetric_state_squeeze_tag")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
    (result $symmetric_tag $symmetric_tag)
  )

  ;;; Compute a new key, that can be used to resume a session
  ;;; without storing a nonce.
  (@interface func (export "symmetric_state_squeeze_key")
    (param $handle $symmetric_state)
    (param $raw (@witx pointer u8))
    (param $raw_len $size)
    (result $error $crypto_errno)
  )

  ;;; Return the maximum length of a for the current algorithm.
  (@interface func (export "symmetric_state_max_tag_len")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Encrypt data.
  ;;; With authenticated encryption, the output will include
  ;;; the authentication tag. Therefore, `$out_len` must be
  ;;; at least `symmetric_state_max_tag_len()` byte larger than
  ;;; the input.
  ;;; If `out` and `data` are the same address, encryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_encrypt")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Encrypt data, with a detached tag.
  ;;; If `out` and `data` are the same address, encryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_encrypt_detached")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $symmetric_tag $symmetric_tag)
  )

  ;;; Decrypt data with an attached tag.
  ;;; If `out` and `data` are the same address, decryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_decrypt")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Decrypt data with a detached tag.
  ;;; If `out` and `data` are the same address, decryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_decrypt_detached")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (param $raw_tag (@witx const_pointer u8))
    (param $raw_tag_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Make it impossible to recover the previous state.
  (@interface func (export "symmetric_state_ratchet")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )
)
