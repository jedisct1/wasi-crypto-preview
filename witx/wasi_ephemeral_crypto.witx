;; WASI Cryptography API

(typename $crypto_errno
  (enum u16
    $success
    $guest_error
    $not_implemented
    $unsupported_feature
    $prohibited_operation
    $unsupported_encoding
    $unsupported_algorithm
    $unsupported_option
    $invalid_key
    $invalid_length
    $verification_failed
    $rng_error
    $algorithm_failure
    $invalid_signature
    $closed
    $invalid_handle
    $overflow
    $internal_error
    $too_many_handles
    $key_not_supported
    $key_required
    $invalid_tag
    $invalid_operation
    $nonce_required
    $option_not_set
  )
)

(typename $keypair_encoding
  (enum u16
    $raw
    $pkcs8
    $der
    $pem
  )
)

(typename $publickey_encoding
  (enum u16
    $raw
    $der
    $pem
    $sec
    $compressed_sec
  )
)

(typename $signature_encoding
  (enum u16
    $raw
    $der
  )
)

(typename $options_type
  (enum u16
    $signatures
    $symmetric
  )
)

(typename $version
  (int u64
    ;;; Key doesn't support versioning.
    (const $unspecified 0xff00000000000000)
    ;;; Retrieve the latest version of a key.
    (const $latest 0xff00000000000001)
    ;;; Perform an operation over all versions of a key.
    (const $all 0xff00000000000002)
  )
)

(typename $size (@witx usize))

(typename $array_output (handle))
(typename $options (handle))
(typename $signature_keypair_manager (handle))
(typename $signature_keypair (handle))
(typename $signature_state (handle))
(typename $signature (handle))
(typename $signature_publickey (handle))
(typename $signature_verification_state (handle))
(typename $symmetric_key_manager (handle))
(typename $symmetric_state (handle))
(typename $symmetric_key (handle))
(typename $symmetric_tag (handle))

(typename $opt_options_u (enum u8 $some $none))
(typename $opt_options (union $opt_options_u (field $some $options) (empty $none)))

(typename $opt_symmetric_key_u (enum u8 $some $none))
(typename $opt_symmetric_key (union $opt_symmetric_key_u (field $some $symmetric_key) (empty $none)))

(module $wasi_ephemeral_crypto
  (import "memory" (memory))

  (@interface func (export "options_open")
    (param $options_type $options_type)
    (result $error $crypto_errno)
    (result $handle $options)
  )

  (@interface func (export "options_close")
    (param $handle $options)
    (result $error $crypto_errno)
  )

  (@interface func (export "options_set")
    (param $handle $options)
    (param $name string)
    (param $value (@witx const_pointer u8))
    (param $value_len $size)
    (result $error $crypto_errno)
  ) 

  (@interface func (export "options_set_u64")
    (param $handle $options)
    (param $name string)
    (param $value u64)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an array_output object.
  (@interface func (export "array_output_len")
    (param $array_output $array_output)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy an array_output into an application-allocated buffer.
  ;;; The array_output handle becomes invalid after this operation.
  (@interface func (export "array_output_pull")
    (param $array_output $array_output)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; Create a context to the key manager
  (@interface func (export "signature_keypair_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair_manager)
  )

  ;;; Destroy a key manager context.
  (@interface func (export "signature_keypair_manager_close")
    (param $kp_manager $signature_keypair_manager)
    (result $error $crypto_errno)
  )

  ;;; Generate a new key pair.
  ;;; This function may return crypto_errno.unsupported_feature if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "signature_keypair_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Import a key pair.
  ;;; This function may return crypto_errno.unsupported_algorithm if the
  ;;; encoding scheme is not supported, or crypto_errno.invalid_key if the key
  ;;; cannot be decoded.
  (@interface func (export "signature_keypair_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Return the key identifier and version, if these are available
  ;;; or $crypto_errno.unsupported_feature if not.
  (@interface func (export "signature_keypair_id")
    (param $kp $signature_keypair)
    (param $kp_id (@witx pointer u8))
    (param $kp_id_max_len $size)
    (result $error $crypto_errno)
    (result $kp_id_len $size)
    (result $version $version)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Create a key pair using an opaque key identifier.
  ;;; Return crypto_errno.unsupported_feature if this operation is not
  ;;; supported by the host, and crypto_errno.invalid_key if the identifier
  ;;; is invalid.
  ;;; The version can be an actual version number or $version.latest .
  (@interface func (export "signature_keypair_from_id")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Invalidate a key pair given a key identifier and a version.
  ;;; Return crypto_errno.unsupported_feature if this operation is not
  ;;; supported by the host, and crypto_errno.invalid_key if the identifier
  ;;; is invalid.
  ;;; The version can be a actual version number, as well as
  ;;; $version.latest or $version.all .
  (@interface func (export "signature_keypair_invalidate")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Export the key pair as the given encoding format.
  ;;; May return crypto_errno.prohibited_operation if this operation is
  ;;; not available or crypto_errno.unsupported_encoding if the encoding
  ;;; is not supported.
  (@interface func (export "signature_keypair_export")
    (param $kp $signature_keypair)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a public key object from the key pair.
  (@interface func (export "signature_keypair_publickey")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Destroys a key pair and wipe memory accordingly.
  (@interface func (export "signature_keypair_close")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
  )

  ;;; Import a public key encoded.
  ;;; Return crypto_errno.unsupported_encoding if exporting
  ;;; to the given format is not implemented or if the format is
  ;;; incompatible with the key type.
  (@interface func (export "signature_publickey_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $publickey_encoding)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Check that a public key is valid and in canonical form.
  ;;; Return crypto_errno.invalid_key is verification fails.
  (@interface func (export "signature_publickey_verify")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Destroys a public key.
  (@interface func (export "signature_publickey_close")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Export a signature in the given format.
  (@interface func (export "signature_export")
    (param $signature $signature)
    (param $encoding $signature_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a signature object by importing a signature encoded
  ;;; in a given format.
  ;;; Return crypto_errno.invalid_signature if the signature is incompatible
  ;;; with the current content.
  (@interface func (export "signature_import")
    (param $algorithm string)
    (param $encoding $signature_encoding)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $signature $signature)
  )

  ;;; Create a new state to collect data to compute a signature on.
  (@interface func (export "signature_state_open")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $state $signature_state)
  )

  ;;; Inject data into the state.
  (@interface func (export "signature_state_update")
    (param $state $signature_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute a signature for all the data collected until tht point.
  ;;; The function can be called multiple times for incremental signing.
  ;;; May return crypto_errno.overflow is too much data has been processed
  ;;; for the chosen algorithm or if system resources have been
  ;;; exceeded.
  (@interface func (export "signature_state_sign")
    (param $state $signature_state)
    (result $error $crypto_errno)
    (result $signature $array_output)
  )

  ;;; Destroy a signature state.
  (@interface func (export "signature_state_close")
    (param $state $signature_state)
    (result $error $crypto_errno)
  )

  ;;; Create a new state to collect data to verify a signature on.
  (@interface func (export "signature_verification_state_update")
    (param $state $signature_verification_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Verify that the given signature is valid for the data collected
  ;;; up to this point.
  (@interface func (export "signature_verification_state_verify")
    (param $state $signature_verification_state)
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature verification state.
  (@interface func (export "signature_verification_state_close")
    (param $state $signature_verification_state)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature.
  (@interface func (export "signature_close")
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an authentication tag.
  (@interface func (export "symmetric_tag_len")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy an authentication tag into an application-allocated buffer.
  ;;; The handle becomes invalid after this operation.
  (@interface func (export "symmetric_tag_pull")
    (param $symmetric_tag $symmetric_tag)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  (@interface func (export "symmetric_tag_verify")
    (param $symmetric_tag $symmetric_tag)
    (param $expected_raw_ptr (@witx const_pointer u8))
    (param $expected_raw_len $size)
    (result $error $crypto_errno)
  )

  ;;; Destroy an authentication tag.
  (@interface func (export "symmetric_tag_close")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
  )

  ;;; Generate a new symmetric key.
  ;;; This function may return crypto_errno.unsupported_feature if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "symmetric_key_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Import a symmetric key.
  ;;; This function may return crypto_errno.unsupported_algorithm if the
  ;;; encoding scheme is not supported, or crypto_errno.invalid_key if the key
  ;;; cannot be decoded.
  (@interface func (export "symmetric_key_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Destroys a symmetric key.
  (@interface func (export "symmetric_key_close")
    (param $symmetric_key $symmetric_key)
    (result $error $crypto_errno)
  )

  ;;; Create a context to construct a key pair.
  (@interface func (export "symmetric_key_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key_manager)
  )

  ;;; Destroy a key pair builder.
  (@interface func (export "symmetric_key_manager_close")
    (param $symmetric_key_manager $symmetric_key_manager)
    (result $error $crypto_errno)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Return the symmetric key identifier and version, if these are available
  ;;; or $crypto_errno.unsupported_feature if not.
  (@interface func (export "symmetric_key_id")
    (param $symmetric_key $symmetric_key)
    (param $symmetric_key_id (@witx pointer u8))
    (param $symmetric_key_id_max_len $size)
    (result $error $crypto_errno)
    (result $symmetric_key_id_len $size)
    (result $version $version)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Create a symmetric key using an opaque key identifier.
  ;;; Return crypto_errno.unsupported_feature if this operation is not
  ;;; supported by the host, and crypto_errno.invalid_key if the identifier
  ;;; is invalid.
  ;;; The version can be an actual version number or $version.latest .
  (@interface func (export "symmetric_key_from_id")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; [OPTIONAL IMPORT]
  ;;; Invalidate a symmetric key given a key identifier and a version.
  ;;; Return crypto_errno.unsupported_feature if this operation is not
  ;;; supported by the host, and crypto_errno.invalid_key if the identifier
  ;;; is invalid.
  ;;; The version can be a actual version number, as well as
  ;;; $version.latest or $version.all .
  (@interface func (export "symmetric_key_invalidate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
  )

  (@interface func (export "symmetric_state_options_get")
    (param $handle $symmetric_state)
    (param $name string)
    (param $value (@witx pointer u8))
    (param $value_max_len $size)
    (result $error $crypto_errno)
    (result $value_len $size)
  ) 
  
  (@interface func (export "symmetric_state_options_get_u64")
    (param $handle $symmetric_state)
    (param $name string)
    (result $error $crypto_errno)
    (result $value u64)
  )

  (@interface func (export "symmetric_state_close")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )   
)
