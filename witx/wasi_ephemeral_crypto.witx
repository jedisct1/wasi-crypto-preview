;; WASI Cryptography API

;;; Error codes.
(typename $crypto_errno
  (enum u16
    ;;; Operation succeeded.
    $success

    ;;; An error occurred when trying to during a conversion from a host type to a guest type.
    ;;;
    ;;; Only an internal bug can throw this error.
    $guest_error

    ;;; The requested operation is valid, but not implemented by the host.
    $not_implemented

    ;;; The requested feature is not supported by the chosen algorithm.
    $unsupported_feature

    ;;; The requested operation is valid, but was administratively prohibited.
    $prohibited_operation

    ;;; Unsupported encoding for an import or export operation.
    $unsupported_encoding

    ;;; The requested algorithm is not supported by the host.
    $unsupported_algorithm

    ;;; The requested option is not supported by the currently selected algorithm.
    $unsupported_option

    ;;; An invalid or incompatible key was supplied.
    ;;;
    ;;; The key may not be valid, or was generated for a different algorithm or parameters set.
    $invalid_key

    ;;; The currently selected algorithm doesn't support the requested output length.
    ;;;
    ;;; This error is thrown by non-extensible hash functions, when requesting an output size larger than they produce out of a single block.
    $invalid_length

    ;;; A signature or authentication tag verification failed.
    $verification_failed

    ;;; A secure random numbers generator is not available.
    ;;;
    ;;; The requested operation requires random numbers, but the host cannot securely generate them at the moment.
    $rng_error

    ;;; An error was returned by the underlying cryptography library.
    ;;;
    ;;; The host may be running out of memory, parameters may be incompatible with the chosen implementation of an algorithm or another unexpected error may have happened.
    ;;;
    ;;; Ideally, the specification should provide enough details and guidance to make this error impossible to ever be thrown.
    ;;;
    ;;; Realistically, the WASI crypto module cannot possibly cover all possible error types implementations can return, especially since some of these may be language-specific.
    ;;; This error can thus be thrown when other error types are not suitable, and when the original error comes from the cryptographic primitives themselves and not from the WASI module.
    $algorithm_failure

    ;;; The supplied signature is invalid, or incompatible with the chosen algorithm.
    $invalid_signature

    ;;; An attempt was made to close a handle that was already closed.
    $closed

    ;;; A function was called with an unassigned handle, a closed handle, or handle of an unexpected type.
    $invalid_handle

    ;;; The host needs to copy data to a guest-allocated buffer, but that buffer is too small.
    $overflow

    ;;; An internal error occurred.
    ;;;
    ;;; This error is reserved to internal consistency checks, and must only be sent if the internal state of the host remains safe after an inconsistency was detected.
    $internal_error

    ;;; Too many handles are currently open, and a new one cannot be created.
    ;;;
    ;;; Implementations are free to represent handles as they want, and to enforce limits to limit resources usage.
    $too_many_handles

    ;;; A key was provided, but the chosen algorithm doesn't support keys.
    ;;;
    ;;; This is returned by symmetric operations.
    ;;;
    ;;; Many hash functions, in particular, do not support keys without being used in particular constructions.
    ;;; Blindly ignoring a key provided by mistake while trying to open a context for such as function could cause serious security vulnerabilities.
    ;;;
    ;;; These functions must refuse to create the context and return this error instead.
    $key_not_supported

    ;;; A key is required for the chosen algorithm, but none was given.
    $key_required

    ;;; The provided authentication tag is invalid or incompatible with the current algorithm.
    ;;;
    ;;; This error is returned by decryption functions and tag verification functions.
    ;;;
    ;;; Unlike `verification_failed`, this error code is returned when the tag cannot possibly verify for any input.
    $invalid_tag

    ;;; The requested operation is incompatible with the current scheme.
    ;;;
    ;;; For example, the `symmetric_state_encrypt()` function cannot complete if the selected construction is a key derivation function.
    ;;; This error code will be returned instead.
    $invalid_operation

    ;;; A nonce is required.
    ;;;
    ;;; Most encryption schemes require a nonce.
    ;;;
    ;;; In the absence of a nonce, the WASI cryptography module can automatically generate one, if that can be done safely. The nonce can be retrieved later with the `symmetric_state_option_get()` function using the `nonce` parameter.
    ;;; If automatically generating a nonce cannot be done safely, the module never falls back to an insecure option and requests an explicit nonce by throwing that error.
    $nonce_required

    ;;; The named option was not set.
    ;;;
    ;;; The caller tried to read the value of an option that was not set.
    ;;; This error is used to make the distinction between an empty option, and an option that was not set and left to its default value.
    $option_not_set

    ;;; A key or key pair matching the requested identifier cannot be found using the supplied information.
    ;;;
    ;;; This error is returned by a key manager via the `signature_keypair_from_id()` function.
    $key_not_found

    ;;; The algorithm requires parameters that haven't been set.
    ;;;
    ;;; Non-generic options are required and must be given by building an `options` set and giving that object to functions instantiating that algorithm.
    $parameters_missing
  )
)

;;; Encoding to use for importing or exporting a key pair.
(typename $keypair_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; PCSK8 encoding.
    $pkcs8

    ;;; DER encoding.
    $der

    ;;; PEM encoding.
    $pem
  )
)

;;; Encoding to use for importing or exporting a public key.
(typename $publickey_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; DER encoding.
    $der

    ;;; PEM encoding.
    $pem

    ;;; SEC encoding.
    $sec

    ;;; Compressed SEC encoding.
    $compressed_sec
  )
)

;;; Encoding to use for importing or exporting a signature.
(typename $signature_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; DER encoding.
    $der
  )
)

;;; Type of an options set.
;;;
;;; This is used when creating a new options set with `options_open()`.
(typename $options_type
  (enum u16
    $signatures
    $symmetric
  )
)

;;; Version of a managed key.
;;;
;;; A version can be an arbitrary `u64` integer, with the expection of some reserved values.
(typename $version
  (int u64
    ;;; Key doesn't support versioning.

    (const $unspecified 0xff00000000000000)
    ;;; Use the latest version of a key.

    (const $latest 0xff00000000000001)

    ;;; Perform an operation over all versions of a key.
    (const $all 0xff00000000000002)
  )
)

;;; Size of a value.
(typename $size (@witx usize))

;;; Handle for functions returning output whose size may be large or not known in advance.
;;;
;;; An `array_output` object contains a host-allocated byte array.
;;;
;;; A guest can get the size of that array after a function returns in order to then allocate a buffer of the correct size.
;;; In addition, the content of such an object can be consumed by a guest in a streaming fashion.
;;;
;;; An `array_output` handle is automatically closed after its full content has been consumed.
(typename $array_output (handle))

;;; A set of options.
;;;
;;; This type is used to set non-default parameters.
;;;
;;; The exact set of allowed options depends on the algorithm being used.
(typename $options (handle))

;;; A handle to the optional key management facilities offered by a host.
;;;
;;; This is used to generate, retrieve and invalidate managed signature key pairs.
(typename $signature_keypair_manager (handle))

;;; A key pair for signatures.
(typename $signature_keypair (handle))

;;; A state to absorb data to be signed.
;;;
;;; After a signature has been computed or verified, the state remains valid for further operations.
;;;
;;; A subsequent signature would sign all the data accumulated since the creation of the state object.
(typename $signature_state (handle))

;;; A signature.
(typename $signature (handle))

;;; A public key that can be used to verify a signature.
(typename $signature_publickey (handle))

;;; A state to absorb signed data to be verified.
(typename $signature_verification_state (handle))

;;; A handle to the optional key management facilities offered by a host.
;;;
;;; This is used to generate, retrieve and invalidate managed symmetric keys.
(typename $symmetric_key_manager (handle))

;;; A state to perform symmetric operations.
;;;
;;; The state is not reset nor invalidated after an option has been performed.
;;; Incremental updates and sessions are thus supported.
(typename $symmetric_state (handle))

;;; A symmetric key.
;;;
;;; The key can be imported from raw bytes, or can be a reference to a managed key.
;;;
;;; If it was imported, the host will wipe it from memory as soon as the handle is closed.
(typename $symmetric_key (handle))

;;; An authentication tag.
;;;
;;; This is an object returned by functions computing authentication tags.
;;;
;;; A tag can be compared against another tag (directly supplied as raw bytes) in constant time with the `symmetric_tag_verify()` function.
;;;
;;; This object type can't be directly created from raw bytes. They are only returned by functions computing MACs.
;;;
;;; The host is reponsible for securely wiping them from memory on close.
(typename $symmetric_tag (handle))

;;; Options index, only required by the Interface Types translation layer.
(typename $opt_options_u (enum u8 $some $none))

;;; An optional options set.
;;;
;;; This union simulates an `Option<Options>` type to make the `options` parameter of some functions optional.
(typename $opt_options (union $opt_options_u (field $some $options) (empty $none)))

;;; Symmetric key index, only required by the Interface Types translation layer.
(typename $opt_symmetric_key_u (enum u8 $some $none))

;;; An optional symmetric key.
;;;
;;; This union simulates an `Option<SymmetricKey>` type to make the `symmetric_key` parameter of some functions optional.
(typename $opt_symmetric_key (union $opt_symmetric_key_u (field $some $symmetric_key) (empty $none)))

;;; A WASI cryptography submodule proposal.
(module $wasi_ephemeral_crypto
  (import "memory" (memory))

  ;;; Create a new object to set non-default options.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let options_handle = ctx.options_open()?;
  ;;; ctx.options_set(options_handle, "context", context)?;
  ;;; ctx.options_set_u64(options_handle, "threads", 4)?;
  ;;; let state = ctx.symmetric_state_open("BLAKE3", None, Some(options_handle))?;
  ;;; ctx.options_close(options_handle)?;
  ;;; ```
  (@interface func (export "options_open")
    (param $options_type $options_type)
    (result $error $crypto_errno)
    (result $handle $options)
  )

  ;;; Destroy an options object.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "options_close")
    (param $handle $options)
    (result $error $crypto_errno)
  )

  ;;; Set or update an option.
  ;;;
  ;;; This is used to set algorithm-specific parameters, but also to provide credentials for the key management facilities, if required.
  ;;;
  ;;; This function may return `unsupported_option` if an option that doesn't exist for any implemented algorithms is specified.
  (@interface func (export "options_set")
    (param $handle $options)
    (param $name string)
    (param $value (@witx const_pointer u8))
    (param $value_len $size)
    (result $error $crypto_errno)
  )

  ;;; Set or update an integer option.
  ;;;
  ;;; This is used to set algorithm-specific parameters.
  ;;;
  ;;; This function may return `unsupported_option` if an option that doesn't exist for any implemented algorithms is specified.
  (@interface func (export "options_set_u64")
    (param $handle $options)
    (param $name string)
    (param $value u64)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an `array_output` object.
  ;;;
  ;;; This allows a guest to allocate a buffer of the correct size in order to copy the output of a function returning this object type.
  (@interface func (export "array_output_len")
    (param $array_output $array_output)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy the content of an `array_output` object into an application-allocated buffer.
  ;;;
  ;;; Multiple calls to that function can be made in order to consume the data in a streaming fashion, if necessary.
  ;;;
  ;;; The function returns the number of bytes that were actually copied. `0` means that the end of the stream has been reached. The total size always matches the output of `array_output_len()`.
  ;;;
  ;;; The handle is automatically closed after all the data has been consumed.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let len = ctx.array_output_len(output_handle)?;
  ;;; let mut out = vec![0u8; len];
  ;;; ctx.array_output_pull(output_handle, &mut out)?;
  ;;; ```
  (@interface func (export "array_output_pull")
    (param $array_output $array_output)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Create a signature context for the key manager.
  ;;;
  ;;; The set of required and supported options is defined by the host.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host.
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair_manager)
  )

  ;;; __(optional)__
  ;;; Destroy a key manager context.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host.
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_manager_close")
    (param $kp_manager $signature_keypair_manager)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Generate a new managed key pair.
  ;;;
  ;;; The key pair is generated and stored by the key management facilities.
  ;;;
  ;;; It may be used through its identifier, but the host may not allow it to be exported.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host,
  ;;; or `unsupported_algorithm` if a key pair cannot be created for the chosen algorithm.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_managed_keypair_generate")
    (param $kp_manager $signature_keypair_manager)
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Generate a new key pair for signatures.
  ;;;
  ;;; Internally, a key pair stores the supplied algorithm and optional parameters.
  ;;;
  ;;; Trying to use that key pair with different parameters will throw an `invalid_key` error.
  ;;;
  ;;; This function may return `$crypto_errno.unsupported_feature` if key generation is not supported by the host for the chosen algorithm.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let kp = ctx.signature_keypair_generate("RSA_PKCS1_2048_8192_SHA512", None)?;
  ;;; ```
  (@interface func (export "signature_keypair_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Import a key pair for signatures.
  ;;;
  ;;; This function creates a `signature_keypair` object from existing material.
  ;;;
  ;;; It may return `unsupported_algorithm` if the encoding scheme is not supported, or `invalid_key` if the key cannot be decoded.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  (@interface func (export "signature_keypair_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; __(optional)__
  ;;; Return the key pair identifier and version of a managed signature key pair.
  ;;;
  ;;; If the key pair is not managed, `unsupported_feature` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_id")
    (param $kp $signature_keypair)
    (param $kp_id (@witx pointer u8))
    (param $kp_id_max_len $size)
    (result $error $crypto_errno)
    (result $kp_id_len $size)
    (result $version $version)
  )

  ;;; __(optional)__
  ;;; Return a managed signature key pair from a key identifier.
  ;;;
  ;;; `kp_version` can be set to `version_latest` to retrieve the most recent version of a key pair.
  ;;;
  ;;; If no key pair matching the provided information is found, `key_not_found` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_from_id")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; __(optional)__
  ;;; Invalidate a managed key pair given a key pair identifier and a version.
  ;;;
  ;;; This asks the key manager to delete or revoke a key pair or a version of a key pair.
  ;;;
  ;;; Once this function returns, `signature_keypair_from_id` will return that key pair any longer.
  ;;;
  ;;; `kp_version` can be set to a version number, to `version.latest` to invalidate the current version, or to `version.all` to invalidate all versions of a key.
  ;;;
  ;;; The function returns `unsupported_feature` if this operation is not supported by the host, and `key_not_found` if the identifier and version don't match any existing key pair.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_invalidate")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Export a signature key pair as the given encoding format.
  ;;;
  ;;; May return `prohibited_operation` if this operation is denied or `unsupported_encoding` if the encoding is not supported.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_export")
    (param $kp $signature_keypair)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Get a public key of a signature key pair.
  ;;;
  ;;; The returned object can be used to verify signatures.
  (@interface func (export "signature_keypair_publickey")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Destroys a signature key pair.
  ;;;
  ;;; The host will automatically wipe traces of the secret key from memory.
  ;;;
  ;;; If this is a managed key, the key will not be removed from persistent storage, and can be reconstructed later using the key identifier.
  (@interface func (export "signature_keypair_close")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
  )

  ;;; Import a signature public key.
  ;;;
  ;;; The returned object can be used to verify signatures.
  ;;;
  ;;; The function may return `unsupported_encoding` if importing from the given format is not implemented or incompatible with the key type.
  ;;;
  ;;; It may also return `invalid_key` if the key doesn't appear to match the supplied algorithm.
  ;;;
  ;;; Finally, the function may return `unsupported_algorithm` if the algorithm is not supported by the host.
  (@interface func (export "signature_publickey_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $publickey_encoding)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Check that a signature public key is valid and in canonical form.
  ;;;
  ;;; This function may perform stricter checks than those made during importation at the expense of additional CPU cycles.
  ;;;
  ;;; The function returns `invalid_key` if the public key didn't pass the checks.
  (@interface func (export "signature_publickey_verify")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Destroys a public key.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "signature_publickey_close")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Export a signature.
  ;;;
  ;;; This function exports a signature object using the specified encoding.
  ;;;
  ;;; May return `unsupported_encoding` if the signature cannot be encoded into the given format.
  (@interface func (export "signature_export")
    (param $signature $signature)
    (param $encoding $signature_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a signature object.
  ;;;
  ;;; This object can be used along with a public key to verify an existing signature.
  ;;;
  ;;; It may return `invalid_signature` if the signature is invalid or incompatible with the specified algorithm, as well as `unsupported_encoding` if the encoding is not compatible with the signature type.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  (@interface func (export "signature_import")
    (param $algorithm string)
    (param $encoding $signature_encoding)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $signature $signature)
  )

  ;;; Create a new state to collect data to compute a signature on.
  ;;;
  ;;; This function allows data to be signed to be supplied in a streaming fashion.
  ;;;
  ;;; The state is not closed and can be used after a signature has been computed, allowing incremental updates by calling `signature_state_update()` again afterwards.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let kp_handle = ctx.signature_keypair_import("Ed25519ph", keypair, KeypairEncoding::Raw)?
  ;;; let state_handle = ctx.signature_state_open(kp_handle)?;
  ;;; ctx.signature_state_update(state_handle, b"message part 1")?;
  ;;; ctx.signature_state_update(state_handle, b"message part 2")?;
  ;;; let sig_handle = ctx.signature_state_sign(state_handle)?;
  ;;; let raw_sig = ctx.signature_export(sig_handle, SignatureEncoding::Raw)?;
  ;;; ```
  (@interface func (export "signature_state_open")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $state $signature_state)
  )

  ;;; Absorb data into the signature state.
  ;;;
  ;;; This function may return `unsupported_feature` is the selected algorithm doesn't support incremental updates.
  (@interface func (export "signature_state_update")
    (param $state $signature_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute a signature for all the data collected up to that point.
  ;;;
  ;;; The function can be called multiple times for incremental signing.
  (@interface func (export "signature_state_sign")
    (param $state $signature_state)
    (result $error $crypto_errno)
    (result $signature $array_output)
  )

  ;;; Destroy a signature state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  ;;;
  ;;; Note that closing a signature state doesn't close or invalidate the key pair object, that be reused for further signatures.
  (@interface func (export "signature_state_close")
    (param $state $signature_state)
    (result $error $crypto_errno)
  )

  ;;; Create a new state to collect data to verify a signature on.
  ;;;
  ;;; This is the verification counterpart of `signature_state`.
  ;;;
  ;;; Data can be injected using `signature_verification_state_update()`, and the state is not closed after a verification, allowing incremental verification.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let pk_handle = ctx.signature_publickey_import("ECDSA_P256_SHA256", encoded_pk PublicKeyEncoding::CompressedSec)?;
  ;;; let signature_handle = ctx.signature_import("ECDSA_P256_SHA256", encoded_sig, PublicKeyEncoding::Der)?;
  ;;; let state_handle = ctx.signature_verification_state_open(pk_handle)?;
  ;;; ctx.signature_verification_state_update(state_handle, "message")?;
  ;;; ctx.signature_verification_state_verify(signature_handle)?;
  ;;; ```
  (@interface func (export "signature_verification_state_open")
    (param $kp $signature_publickey)
    (result $error $crypto_errno)
    (result $state $signature_verification_state)
  )

  ;;; Absorb data into the signature verification state.
  ;;;
  ;;; This function may return `unsupported_feature` is the selected algorithm doesn't support incremental updates.
  (@interface func (export "signature_verification_state_update")
    (param $state $signature_verification_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Check that the given signature is verifies for the data collected up to that point point.
  ;;;
  ;;; The state is not closed and can absorb more data to allow for incremental verification.
  ;;;
  ;;; The function returns `invalid_signature` if the signature doesn't appear to be valid.
  (@interface func (export "signature_verification_state_verify")
    (param $state $signature_verification_state)
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature verification state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  ;;;
  ;;; Note that closing a signature state doesn't close or invalidate the public key object, that be reused for further verifications.
  (@interface func (export "signature_verification_state_close")
    (param $state $signature_verification_state)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "signature_close")
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an authentication tag.
  ;;;
  ;;; This function can be used by a guest to allocate the correct buffer size to copy a computed authentication tag.
  (@interface func (export "symmetric_tag_len")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy an authentication tag into a guest-allocated buffer.
  ;;;
  ;;; The handle automatically becomes invalid after this operation. Manually closing it is not required.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let mut raw_tag = [0u8; 16];
  ;;; ctx.symmetric_tag_pull(raw_tag_handle, &mut raw_tag)?;
  ;;; ```
  ;;;
  ;;; The function returns `overflow` if the supplied buffer is too small to copy the tag.
  (@interface func (export "symmetric_tag_pull")
    (param $symmetric_tag $symmetric_tag)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; Verify that a computed authentication tag matches the expected value, in constant-time.
  ;;;
  ;;; The expected tag must be provided as a raw byte string.
  ;;;
  ;;; The function returns `invalid_tag` if the tags don't match.
  (@interface func (export "symmetric_tag_verify")
    (param $symmetric_tag $symmetric_tag)
    (param $expected_raw_tag_ptr (@witx const_pointer u8))
    (param $expected_raw_tag_len $size)
    (result $error $crypto_errno)
  )

  ;;; Destroy an authentication tag.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "symmetric_tag_close")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
  )

  ;;; Generate a new symmetric key for a gigven algorithm.
  ;;;
  ;;; `options` can be `None` to use the default parameters, or an algoritm-specific set of parameters to override.
  ;;;
  ;;; This function may return `unsupported_feature` if key generation is not supported by the host for the chosen algorithm, or `unsupported_algorithm` if the algorithm is not supported by the host.
  (@interface func (export "symmetric_key_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Create a symmetric key from raw material.
  ;;;
  ;;; The algorithm is internally stored along with the key, and trying to use the key with an operation expecting a different algorithm will return `invalid_key`.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  (@interface func (export "symmetric_key_import")
    (param $algorithm string)
    (param $raw (@witx const_pointer u8))
    (param $raw_len $size)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Destroy a symmetric key.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "symmetric_key_close")
    (param $symmetric_key $symmetric_key)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Create a context for the key manager, for symmetric operations.
  ;;;
  ;;; The set of required and supported options is defined by the host.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host.
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "symmetric_key_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key_manager)
  )

  ;;; __(optional)__
  ;;; Destroy a key manager context.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host.
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "symmetric_key_manager_close")
    (param $symmetric_key_manager $symmetric_key_manager)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Generate a new symmetric key.
  ;;;
  ;;; The key is generated and stored by the key management facilities.
  ;;;
  ;;; It may be used through its identifier, but the host may not allow it to be exported.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host,
  ;;; or `unsupported_algorithm` if a key cannot be created for the chosen algorithm.
  ;;;
  ;;; The function may also return `unsupported_algorithm` if the algorithm is not supported by the host.
  ;;;
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "symmetric_managed_key_generate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; __(optional)__
  ;;; Return the key identifier and version of a managed symmetric key pair.
  ;;;
  ;;; If the key is not managed, `unsupported_feature` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "symmetric_key_id")
    (param $symmetric_key $symmetric_key)
    (param $symmetric_key_id (@witx pointer u8))
    (param $symmetric_key_id_max_len $size)
    (result $error $crypto_errno)
    (result $symmetric_key_id_len $size)
    (result $version $version)
  )

  ;;; __(optional)__
  ;;; Return a managed symmetric key from a key identifier.
  ;;;
  ;;; `kp_version` can be set to `version_latest` to retrieve the most recent version of a key pair.
  ;;;
  ;;; If no key matching the provided information is found, `key_not_found` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "symmetric_key_from_id")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; __(optional)__
  ;;; Invalidate a symmetric key given a key identifier and a version.
  ;;;
  ;;; This asks the key manager to delete or revoke a key or a version of a key.
  ;;;
  ;;; Once this function returns, `symmetric_key_from_id` will return that key any longer.
  ;;;
  ;;; `kp_version` can be set to a version number, to `version.latest` to invalidate the current version, or to `version.all` to invalidate all versions of a key.
  ;;;
  ;;; The function returns `unsupported_feature` if this operation is not supported by the host, and `key_not_found` if the identifier and version don't match any existing key pair.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "symmetric_key_invalidate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
  )

  ;;; Create a new state to aborb and produce data using symmetric operations.
  ;;;
  ;;; The state remains valid after every operation in order to support incremental updates.
  ;;;
  ;;; The function has two optional parameters: a key and an options set.
  ;;;
  ;;; It will fail with a `key_not_supported` error code if a key was provided but the chosen algorithm doesn't natively support keying.
  ;;;
  ;;; On the other hand, if a key is required, but was not provided, a `key_required` error will be thrown.
  ;;;
  ;;; Some algorithms may require additional parameters. They have to be supplied as an options set:
  ;;;
  ;;; ```rust
  ;;; let options_handle = ctx.options_open()?;
  ;;; ctx.options_set("context", b"My application")?;
  ;;; ctx.options_set_u64("fanout", 16)?;
  ;;; let state_handle = ctx.symmetric_state_open("BLAKE2b-512", None, Some(options_handle))?;
  ;;; ```
  ;;;
  ;;; If some parameters are mandatory but were not set, the `parameters_missing` error code will be returned.
  ;;;
  ;;; A notable exception is the `nonce` parameter, that is common to most AEAD constructions.
  ;;;
  ;;; If a nonce is required but was not supplied:
  ;;;
  ;;; - If it is safe to do so, the host will automatically generate a nonce. This is true for nonces that are large enough to be randomly generated, or if the host is able to maintain a global counter.
  ;;; - If not, the function will fail and return the dedicated `nonce_required` error code.
  ;;;
  ;;; A nonce that was automatically generated can be retrieved after the function returns with `symmetric_state_get(state_handle, "nonce")`.
  ;;;
  ;;; **Sample usage patterns:**
  ;;;
  ;;; - **Hashing**
  ;;;
  ;;; ```rust
  ;;; let mut out = [0u8; 64];
  ;;; let state_handle = ctx.symmetric_state_open("SHAKE-128", None, None)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"data")?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"more_data")?;
  ;;; ctx.symmetric_state_squeeze(state_handle, &mut out)?;
  ;;; ```
  ;;;
  ;;; - **MAC**
  ;;;
  ;;; ```rust
  ;;; let mut out = [0u8; 64];
  ;;; let key_handle = ctx.symmetric_key_import("HMAC/SHA-512", b"key")?;
  ;;; let state_handle = ctx.symmetric_state_open("HMAC/SHA-512", Some(key_handle), None)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"data")?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"more_data")?;
  ;;; ctx.symmetric_state_squeeze(state_handle, &mut out)?;
  ;;; ```
  ;;;
  ;;; - **Tuple hashing**
  ;;;
  ;;; ```rust
  ;;; let mut out = [0u8; 64];
  ;;; let state_handle = ctx.symmetric_state_open("TupleHashXOF256", None, None)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"value 1")?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"value 2")?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"value 3")?;
  ;;; ctx.symmetric_state_squeeze(state_handle, &mut out)?;
  ;;; ```
  ;;; Unlike MACs and regular hash functions, inputs are domain separated instead of being concatenated.
  ;;;
  ;;; - **Key derivation using extract-and-expand**
  ;;;
  ;;; Extract:
  ;;;
  ;;; ```rust
  ;;; let key_handle = ctx.symmetric_key_import("HKDF-EXTRACT/SHA-512", b"key")?;
  ;;; let state_handle = symmetric_state_open("HKDF-EXTRACT/SHA-512", Some(key_handle), None)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"seed")?;
  ;;; let prk_handle = ctx.symmetric_state_squeeze_key(state_handle)?;
  ;;; ```
  ;;; Expand:
  ;;;
  ;;; ```rust
  ;;; let mut subkey = vec![0u8; 32];
  ;;; let state_handle = symmetric_state_open("HKDF-EXPAND/SHA-512", Some(prk_handle), None)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"salt")?;
  ;;; ctx.symmetric_state_squeeze(state_handle, &mut subkey)?;
  ;;; ```
  ;;;
  ;;; - **Key derivation using a XOF**
  ;;;
  ;;; ```rust
  ;;; let mut subkey1 = vec![0u8; 32];
  ;;; let mut subkey2 = vec![0u8; 32];
  ;;; let key_handle = ctx.symmetric_key_import("BLAKE3", b"key")?;
  ;;; let state_handle = symmetric_state_open("BLAKE3", Some(key_handle), None)?;
  ;;; ctx.symmetric_absorb(state_handle, b"context")?;
  ;;; ctx.squeeze(state_handle, &mut subkey1)?;
  ;;; ctx.squeeze(state_handle, &mut subkey2)?;
  ;;; ```
  ;;;
  ;;; - **Password hashing**
  ;;;
  ;;; ```rust
  ;;; let options_handle = ctx.symmetric_options_open()?;
  ;;; ctx.symmetric_options_set_u64(options_handle, "memlimit", 1 * 1024 * 1024 * 1024)?;
  ;;; ctx.symmetric_options_set_u64(options_handle, "opslimit", 5)?;
  ;;; ctx.symmetric_options_set_u64(options_handle, "parallelism", 8)?;
  ;;;
  ;;; let state_handle = ctx.symmetric_state_open("Argon2id", None, Some(options))?;
  ;;; ctx.symmtric_state_absorb(state_handle, b"password")?;
  ;;;
  ;;; let pw_str_handle = ctx.symmetric_state_squeeze_tag(state_handle)?;
  ;;; let mut pw_str = vec![0u8; ctx.symmetric_tag_len(pw_str_handle)?];
  ;;; ctx.symmetric_tag_pull(pw_str_handle, &mut pw_str)?;
  ;;; ```
  ;;;
  ;;; - **AEAD encryption with an explicit nonce**
  ;;;
  ;;; ```rust
  ;;; let key_handle = ctx.symmetric_key_generate("AES-256-GCM", None)?;
  ;;; let message = b"test";
  ;;;
  ;;; let options_handle = ctx.symmetric_options_open()?;
  ;;; ctx.symmetric_options_set(options_handle, "nonce", nonce)?;
  ;;;
  ;;; let state_handle = ctx.symmetric_state_open("AES-256-GCM", Some(key_handle), Some(options_handle))?;
  ;;; let mut ciphertext = vec![0u8; message.len() + ctx.symmetric_state_max_tag_len(state_handle)?];
  ;;; ctx.symmetric_state_absorb(state_handle, "additional data")?;
  ;;; ctx.symmetric_state_encrypt(state_handle, &mut ciphertext, message)?;
  ;;; ```
  ;;;
  ;;; - **AEAD encryption with automatic nonce generation**
  ;;;
  ;;; ```rust
  ;;; let key_handle = ctx.symmetric_key_generate("XChaCha20-Poly1305", None)?;
  ;;; let message = b"test";
  ;;; let mut nonce = [0u8; 24];
  ;;;
  ;;; let state_handle = ctx.symmetric_state_open("XChaCha20-Poly1305", Some(key_handle), None)?;
  ;;;
  ;;; let nonce_handle = ctx.symmetric_state_options_get(state_handle, "nonce")?;
  ;;; ctx.array_output_pull(nonce_handle, &mut nonce)?;
  ;;;
  ;;; let mut ciphertext = vec![0u8; message.len() + ctx.symmetric_state_max_tag_len(state_handle)?];
  ;;; ctx.symmetric_state_absorb(state_handle, "additional data")?;
  ;;; ctx.symmetric_state_encrypt(state_handle, &mut ciphertext, message)?;
  ;;; ```
  ;;;
  ;;; - **Session authenticated modes**
  ;;;
  ;;; ```rust
  ;;; let mut out = [0u8; 16];
  ;;; let mut out2 = [0u8; 16];
  ;;; let mut ciphertext = [0u8; 20];
  ;;; let key_handle = ctx.symmetric_key_generate("Xoodyak-256", None)?;
  ;;; let state_handle = ctx.symmetric_state_open("Xoodyak-256", Some(key_handle), None)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"data")?;
  ;;; ctx.symmetric_state_encrypt(state_handle, &mut ciphertext, b"abcd")?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"more data")?;
  ;;; ctx.symmetric_state_squeeze(state_handle, &mut out)?;
  ;;; ctx.symmetric_state_squeeze(state_handle, &mut out2)?;
  ;;; ctx.symmetric_state_ratchet(state_handle)?;
  ;;; ctx.symmetric_state_absorb(state_handle, b"more data")?;
  ;;; let next_key_handle = ctx.symmetric_state_squeeze_key(state_handle)?;
  ;;; // ...
  ;;; ```

  (@interface func (export "symmetric_state_open")
    (param $algorithm string)
    (param $key $opt_symmetric_key)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $symmetric_state $symmetric_state)
  )

  ;;; Retrieve a parameter from the current state.
  ;;;
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used to get a nonce that as automatically generated.
  ;;;
  ;;; The function may return `options_not_set` if an option was not set, which is different from an empty value.
  ;;;
  ;;; It may also return `unsupported_option` if the option doesn't exist for the chosen algorithm.
  (@interface func (export "symmetric_state_options_get")
    (param $handle $symmetric_state)
    (param $name string)
    (param $value (@witx pointer u8))
    (param $value_max_len $size)
    (result $error $crypto_errno)
    (result $value_len $size)
  )

  ;;; Retrieve an integer parameter from the current state.
  ;;;
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used to get a nonce that as automatically generated.
  ;;;
  ;;; The function may return `options_not_set` if an option was not set.
  ;;;
  ;;; It may also return `unsupported_option` if the option doesn't exist for the chosen algorithm.
  (@interface func (export "symmetric_state_options_get_u64")
    (param $handle $symmetric_state)
    (param $name string)
    (result $error $crypto_errno)
    (result $value u64)
  )

  ;;; Destroy a symmetric state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "symmetric_state_close")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )

  ;;; Absorb data into the state.
  ;;;
  ;;; - **Hash functions:** adds data to be hashed.
  ;;; - **MAC functions:** adds data to be authenticated.
  ;;; - **Tuplehash-like constructions:** adds a new tuple to the state.
  ;;; - **Key derivation functions:** adds to the IKM or to the subkey information.
  ;;; - **AEAD constructions:** adds additional data to be authenticated.
  ;;; - **Stateful hash objects, permutation-based constructions:** absorbs.
  ;;;
  ;;; If the chosen algorithm doesn't accept input data, the `invalid_operation` error code is returned.
  ;;;
  ;;; If too much data has been fed for the algorithm, `overflow` may be thrown.
  (@interface func (export "symmetric_state_absorb")
    (param $handle $symmetric_state)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
  )

  ;;; Squeeze bytes from the state.
  ;;;
  ;;; - **Hash functions:** this tries to output an `out_len` bytes digest from the absorbed data. The hash function output will be truncated if necessary. If the requested size is too large, the `invalid_len` error code is returned.
  ;;; - **Key derivation functions:** : outputs an arbitrary-long derived key.
  ;;; - **RNGs, DRBGs, stream ciphers:**: outputs arbitrary-long data.
  ;;; - **Stateful hash objects, permutation-based constructions:** squeeze.
  ;;;
  ;;; Other kinds of algorithms may return `invalid_operation` instead.
  (@interface func (export "symmetric_state_squeeze")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute and return a tag for all the data injected into the state so far.
  ;;;
  ;;; - **MAC functions**: returns a tag authenticating the absorbed data.
  ;;; - **Tuplehash-like constructions:** returns a tag authenticating all the absorbed tuples.
  ;;; - **Password-hashing functions:** returns a standard string containing all the required parameters for password verification.
  ;;;
  ;;; Other kinds of algorithms may return `invalid_operation` instead.
  (@interface func (export "symmetric_state_squeeze_tag")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
    (result $symmetric_tag $symmetric_tag)
  )

  ;;; Compute a new key, that can be used to resume a session without storing a nonce.
  ;;;
  ;;; This is similar to `symmetric_state_squeeze()` with a different domain.
  ;;;
  ;;; For extract-then-expand constructions, this returns the PRK.
  ;;;
  ;;; `invalid_operation` is returned for algorithms not supporting this operation.
  (@interface func (export "symmetric_state_squeeze_key")
    (param $handle $symmetric_state)
    (param $raw (@witx pointer u8))
    (param $raw_len $size)
    (result $error $crypto_errno)
  )

  ;;; Return the maximum length of an authentication tag for the current algorithm.
  ;;;
  ;;; This allows guests to compute the size required to store a ciphertext along with its authentication tag.
  ;;;
  ;;; The returned length may include the encryption mode's padding requirements in addition to the actual tag.
  ;;;
  ;;; For an encryption operation, the size of the output buffer should be `input_len + symmetric_state_max_tag_len()`.
  ;;;
  ;;; For a decryption operation, the size of the buffer that will store the decrypted data can be reduced to `ciphertext_len - symmetric_state_max_tag_len()` only if the algorithm is known to have a fixed tag length.
  (@interface func (export "symmetric_state_max_tag_len")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Encrypt data with an attached tag.
  ;;;
  ;;; - **Stream cipher:** adds the input to the stream cipher output. `out_len` and `data_len` can be equal, as no authentication tags will be added.
  ;;; - **AEAD:** encrypts `data` into `out`, including the authentication tag to the output. Additional data must have been previously absorbed using `symmetric_state_absorb()`. The `symmetric_state_max_tag_len()` function can be used to retrieve the overhead of adding the tag, as well as padding if necessary.
  ;;; - **SHOE, Xoodyak, Strobe:** encrypts data, squeezes a tag and appends it to the output.
  ;;;
  ;;; If `out` and `data` are the same address, encryption may happen in-place.
  ;;;
  ;;; The function returns the actual size of the ciphertext along with the tag.
  ;;;
  ;;; `invalid_operation` is returned for algorithms not supporting encryption.
  (@interface func (export "symmetric_state_encrypt")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Encrypt data, with a detached tag.
  ;;;
  ;;; - **Stream cipher:** returns `invalid_operation` since stream ciphers do not include authentication tags.
  ;;; - **AEAD:** encrypts `data` into `out` and returns the tag separately. Additional data must have been previously absorbed using `symmetric_state_absorb()`. The output and input buffers can be of the same length.
  ;;; - **SHOE, Xoodyak, Strobe:** encrypts data and squeezes a tag.
  ;;;
  ;;; If `out` and `data` are the same address, encryption may happen in-place.
  ;;;
  ;;; The function returns the tag.
  ;;;
  ;;; `invalid_operation` is returned for algorithms not supporting encryption.
  (@interface func (export "symmetric_state_encrypt_detached")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $symmetric_tag $symmetric_tag)
  )

  ;;; - **Stream cipher:** adds the input to the stream cipher output. `out_len` and `data_len` can be equal, as no authentication tags will be added.
  ;;; - **AEAD:** decrypts `data` into `out`. Additional data must have been previously absorbed using `symmetric_state_absorb()`.
  ;;; - **SHOE, Xoodyak, Strobe:** decrypts data, squeezes a tag and verify that it matches the one that was appended to the ciphertext.
  ;;;
  ;;; If `out` and `data` are the same address, decryption may happen in-place.
  ;;;
  ;;; The function returns the actual size of the decrypted message.
  ;;;
  ;;; `invalid_tag` is returned if the tag didn't verify.
  ;;;
  ;;; `invalid_operation` is returned for algorithms not supporting encryption.
  (@interface func (export "symmetric_state_decrypt")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; - **Stream cipher:** returns `invalid_operation` since stream ciphers do not include authentication tags.
  ;;; - **AEAD:** decrypts `data` into `out`. Additional data must have been previously absorbed using `symmetric_state_absorb()`.
  ;;; - **SHOE, Xoodyak, Strobe:** decrypts data, squeezes a tag and verify that it matches the expected one.
  ;;;
  ;;; `raw_tag` is the expected tag, as raw bytes.
  ;;;
  ;;; If `out` and `data` are the same address, decryption may happen in-place.
  ;;;
  ;;; The function returns the actual size of the decrypted message.
  ;;;
  ;;; `invalid_tag` is returned if the tag verification failed.
  ;;;
  ;;; `invalid_operation` is returned for algorithms not supporting encryption.
  (@interface func (export "symmetric_state_decrypt_detached")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (param $raw_tag (@witx const_pointer u8))
    (param $raw_tag_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Make it impossible to recover the previous state.
  ;;;
  ;;; This operation is supported by some systems keeping a rolling state over an entire session, for forward security.
  ;;;
  ;;; `invalid_operation` is returned for algorithms not supporting ratcheting.
  (@interface func (export "symmetric_state_ratchet")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )
)
