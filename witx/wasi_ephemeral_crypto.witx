;; WASI Cryptography API

;;; Error codes.
(typename $crypto_errno
  (enum u16
    ;;; Operation succeeded.  
    $success

    ;;; An error occurred when trying to during a conversion from a host type to a guest type.
    ;;;
    ;;; Only an internal bug can throw this error.
    $guest_error

    ;;; The requested operation is valid, but not implemented by the host.
    $not_implemented

    ;;; The requested feature is not supported by the chosen algorithm.
    $unsupported_feature

    ;;; The requested operation is valid, but was administratively prohibited.
    $prohibited_operation

    ;;; Unsupported encoding for an import or export operation.
    $unsupported_encoding

    ;;; The requested algorithm is not supported by the host.
    $unsupported_algorithm

    ;;; The requested option is not supported by the currently selected algorithm.
    $unsupported_option

    ;;; An invalid or incompatible key was supplied.
    ;;;
    ;;; The key may not be valid, or was generated for a different algorithm or parameters set.
    $invalid_key

    ;;; The currently selected algorithm doesn't support the requested output length.
    ;;;
    ;;; This error is thrown by non-extensible hash functions, when requesting an output size larger than they produce out of a single block.
    $invalid_length

    ;;; A signature or authentication tag verification failed.
    $verification_failed

    ;;; A secure random numbers generator is not available.
    ;;;
    ;;; The requested operation requires random numbers, but the host cannot securely generate them at the moment. 
    $rng_error

    ;;; An error was returned by the underlying cryptography library.
    ;;;
    ;;; The host may be running out of memory, parameters may be incompatible with the chosen implementation of an algorithm or another unexpected error may have happened.
    ;;;
    ;;; Ideally, the specification should provide enough details and guidance to make this error impossible to ever be thrown.
    ;;;
    ;;; Realistically, the WASI crypto module cannot possibly cover all possible error types implementations can return, especially since some of these may be language-specific.
    ;;; This error can thus be thrown when other error types are not suitable, and when the original error comes from the cryptographic primitives themselves and not from the WASI module.
    $algorithm_failure

    ;;; The supplied signature is invalid, or incompatible with the chosen algorithm.
    $invalid_signature

    ;;; An attempt was made to close a handle that was already closed.
    $closed

    ;;; A function was called with an unassigned handle, a closed handle, or handle of an unexpected type.
    $invalid_handle

    ;;; The host needs to copy data to a guest-allocated buffer, but that buffer is too small.
    $overflow

    ;;; An internal error occurred.
    ;;;
    ;;; This error is reserved to internal consistency checks, and must only be sent if the internal state of the host remains safe after an inconsistency was detected.
    $internal_error

    ;;; Too many handles are currently open, and a new one cannot be created.
    ;;;
    ;;; Implementations are free to represent handles as they want, and to enforce limits to limit resources usage.
    $too_many_handles

    ;;; A key was provided, but the chosen algorithm doesn't support keys.
    ;;;
    ;;; This is returned by symmetric operations.
    ;;;
    ;;; Many hash functions, in particular, do not support keys without being used in particular constructions.
    ;;; Blindly ignoring a key provided by mistake while trying to open a context for such as function could cause serious security vulnerabilities.
    ;;;
    ;;; These functions must refuse to create the context and return this error instead.
    $key_not_supported

    ;;; A key is required for the chosen algorithm, but none was given.
    $key_required

    ;;; The provided authentication tag is invalid or incompatible with the current algorithm.
    ;;;
    ;;; This error is returned by decryption functions and tag verification functions.
    ;;;
    ;;; Unlike `verification_failed`, this error code is returned when the tag cannot possibly verify for any input.
    $invalid_tag

    ;;; The requested operation is incompatible with the current scheme.
    ;;;
    ;;; For example, the `symmetric_state_encrypt()` function cannot complete if the selected construction is a key derivation function.
    ;;; This error code will be returned instead.
    $invalid_operation

    ;;; A nonce is required.
    ;;;
    ;;; Most encryption schemes require a nonce.
    ;;;
    ;;; In the absence of a nonce, the WASI cryptography module can automatically generate one, if that can be done safely. The nonce can be retrieved later with the `symmetric_state_option_get()` function using the `nonce` parameter.
    ;;; If automatically generating a nonce cannot be done safely, the module never falls back to an insecure option and requests an explicit nonce by throwing that error.
    $nonce_required

    ;;; The named option was not set.
    ;;;
    ;;; The caller tried to read the value of an option that was not set.
    ;;; This error is used to make the distinction between an empty option, and an option that was not set and left to its default value.
    $option_not_set
    
    ;;; A key or key pair matching the requested identifier cannot be found using the supplied information.
    ;;;
    ;;; This error is returned by a key manager via the `signature_keypair_from_id()` function.
    $key_not_found
  )
)

;;; Encoding to use for importing or exporting a key pair.
(typename $keypair_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; PCSK8 encoding.
    $pkcs8

    ;;; DER encoding.
    $der

    ;;; PEM encoding.
    $pem
  )
)

;;; Encoding to use for importing or exporting a public key.
(typename $publickey_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; DER encoding.
    $der

    ;;; PEM encoding.
    $pem

    ;;; SEC encoding.
    $sec

    ;;; Compressed SEC encoding.
    $compressed_sec
  )
)

;;; Encoding to use for importing or exporting a signature.
(typename $signature_encoding
  (enum u16
    ;;; Raw bytes.
    $raw

    ;;; DER encoding.
    $der
  )
)

;;; Type of an options set.
;;;
;;; This is used when creating a new options set with `options_open()`.
(typename $options_type
  (enum u16
    $signatures
    $symmetric
  )
)

;;; Version of a managed key.
;;;
;;; A version can be an arbitrary `u64` integer, with the expection of some reserved values.
(typename $version
  (int u64
    ;;; Key doesn't support versioning.

    (const $unspecified 0xff00000000000000)
    ;;; Use the latest version of a key.

    (const $latest 0xff00000000000001)

    ;;; Perform an operation over all versions of a key.
    (const $all 0xff00000000000002)
  )
)

;;; Size of a value.
(typename $size (@witx usize))

;;; Handle for functions returning output whose size may be large or not known in advance.
;;;
;;; An `array_output` object contains a host-allocated byte array.
;;;
;;; A guest can get the size of that array after a function returns in order to then allocate a buffer of the correct size.
;;; In addition, the content of such an object can be consumed by a guest in a streaming fashion.
;;;
;;; An `array_output` handle is automatically closed after its full content has been consumed.
(typename $array_output (handle))

;;; A set of options.
;;;
;;; This type is used to set non-default parameters.
;;;
;;; The exact set of allowed options depends on the algorithm being used.
(typename $options (handle))

;;; A handle to the optional key management facilities offered by a host.
;;;
;;; This is used to generate, retrieve and invalidate managed signature key pairs.
(typename $signature_keypair_manager (handle))

;;; A key pair for signatures.
(typename $signature_keypair (handle))

;;; A state to absorb data to be signed.
;;;
;;; After a signature has been computed or verified, the state remains valid for further operations.
;;;
;;; A subsequent signature would sign all the data accumulated since the creation of the state object.
(typename $signature_state (handle))

;;; A signature.
(typename $signature (handle))

;;; A public key that can be used to verify a signature.
(typename $signature_publickey (handle))

;;; A state to absorb signed data to be verified.
(typename $signature_verification_state (handle))

;;; A handle to the optional key management facilities offered by a host.
;;;
;;; This is used to generate, retrieve and invalidate managed symmetric keys.
(typename $symmetric_key_manager (handle))

;;; A state to perform symmetric operations.
;;;
;;; The state is not reset nor invalidated after an option has been performed.
;;; Incremental updates and sessions are thus supported.
(typename $symmetric_state (handle))

;;; A symmetric key.
;;;
;;; The key can be imported from raw bytes, or can be a reference to a managed key.
;;;
;;; If it was imported, the host will wipe it from memory as soon as the handle is closed.
(typename $symmetric_key (handle))

;;; An authentication tag.
;;;
;;; This is an object returned by functions computing authentication tags.
;;;
;;; A tag can be compared against another tag (directly supplied as raw bytes) in constant time with the `symmetric_tag_verify()` function.
;;;
;;; This object type can't be directly created from raw bytes. They are only returned by functions computing MACs.
;;;
;;; The host is reponsible for securely wiping them from memory on close.
(typename $symmetric_tag (handle))

;;; Options index, only required by the Interface Types translation layer.
(typename $opt_options_u (enum u8 $some $none))

;;; An optional options set.
;;;
;;; This union simulates an `Option<Options>` type to make the `options` parameter of some functions optional.
(typename $opt_options (union $opt_options_u (field $some $options) (empty $none)))

;;; Symmetric key index, only required by the Interface Types translation layer.
(typename $opt_symmetric_key_u (enum u8 $some $none))

;;; An optional symmetric key.
;;;
;;; This union simulates an `Option<SymmetricKey>` type to make the `symmetric_key` parameter of some functions optional.
(typename $opt_symmetric_key (union $opt_symmetric_key_u (field $some $symmetric_key) (empty $none)))

;;; A WASI cryptography submodule proposal.
(module $wasi_ephemeral_crypto
  (import "memory" (memory))

  ;;; Create a new object to set non-default options.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let options_handle = ctx.options_open()?;
  ;;; ctx.options_set(options_handle, "context", context)?;
  ;;; ctx.options_set_u64(options_handle, "threads", 4)?;
  ;;; let state = ctx.symmetric_state_open("BLAKE3", None, Some(options_handle))?;
  ;;; ctx.options_close(options_handle)?;
  ;;; ```
  (@interface func (export "options_open")
    (param $options_type $options_type)
    (result $error $crypto_errno)
    (result $handle $options)
  )

  ;;; Destroy an options object.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "options_close")
    (param $handle $options)
    (result $error $crypto_errno)
  )

  ;;; Set or update an option.
  ;;;
  ;;; This is used to set algorithm-specific parameters, but also to provide credentials for the key management facilities, if required.
  (@interface func (export "options_set")
    (param $handle $options)
    (param $name string)
    (param $value (@witx const_pointer u8))
    (param $value_len $size)
    (result $error $crypto_errno)
  )

  ;;; Set or update an integer option.
  ;;;
  ;;; This is used to set algorithm-specific parameters.
  (@interface func (export "options_set_u64")
    (param $handle $options)
    (param $name string)
    (param $value u64)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an `array_output` object.
  ;;;
  ;;; This allows a guest to allocate a buffer of the correct size in order to copy the output of a function returning this object type.
  (@interface func (export "array_output_len")
    (param $array_output $array_output)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy the content of an `array_output` object into an application-allocated buffer.
  ;;;
  ;;; Multiple calls to that function can be made in order to consume the data in a streaming fashion, if necessary.
  ;;;
  ;;; The function returns the number of bytes that were actually copied. `0` means that the end of the stream has been reached. The total size always matches the output of `array_output_len()`.
  ;;;
  ;;; The handle is automatically closed after all the data has been consumed.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let len = ctx.array_output_len(output_handle)?;
  ;;; let mut out = vec![0u8; len];
  ;;; ctx.array_output_pull(output_handle, &mut out)?;
  ;;; ```
  (@interface func (export "array_output_pull")
    (param $array_output $array_output)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Create a context to the key manager.
  ;;;
  ;;; The set of required and supported options is defined by the host.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host.
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair_manager)
  )

  ;;; __(optional)__
  ;;; Destroy a key manager context.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host.
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_manager_close")
    (param $kp_manager $signature_keypair_manager)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Generate a new managed key pair.
  ;;;
  ;;; The key pair is generated and stored by the key management facilities.
  ;;;
  ;;; It may be used through its identifier, but the host may not allow it to be exported.
  ;;;
  ;;; The function returns the `unsupported_feature` error code if key management facilities are not supported by the host,
  ;;; or `unsupported_algorithm` if a key cannot be created for the chosen algorithm.
  ;;;
  ;;; This is also an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_managed_keypair_generate")
    (param $kp_manager $signature_keypair_manager)
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Generate a new key pair for signatures.
  ;;;
  ;;; Internally, a key pair stores the supplied algorithm and optional parameters.
  ;;;
  ;;; Trying to use that key pair with different parameters will throw an `invalid_key` error.
  ;;;
  ;;; This function may return `$crypto_errno.unsupported_feature` if key generation is not supported by the host for the chosen algorithm.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let kp = ctx.signature_keypair_generate("RSA_PKCS1_2048_8192_SHA512", None)?;
  ;;; ```
  (@interface func (export "signature_keypair_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; Import a key pair for signatures.
  ;;;
  ;;; This function creates a `signature_keypair` object from existing material.
  ;;;
  ;;; It may return `unsupported_algorithm` if the encoding scheme is not supported, or `invalid_key` if the key cannot be decoded.
  (@interface func (export "signature_keypair_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; __(optional)__
  ;;; Return the key identifier and version of a managed signature key pair.
  ;;;
  ;;; If the key pair is not managed, `unsupported_feature` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_id")
    (param $kp $signature_keypair)
    (param $kp_id (@witx pointer u8))
    (param $kp_id_max_len $size)
    (result $error $crypto_errno)
    (result $kp_id_len $size)
    (result $version $version)
  )

  ;;; __(optional)__
  ;;; Return a managed signature key pair from a key identifier.
  ;;;
  ;;; `kp_version` can be set to `version_latest` to retrieve the most recent version of a key pair.
  ;;;
  ;;; If no key matching the provided information is found, `key_not_found` is returned instead.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_from_id")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
    (result $handle $signature_keypair)
  )

  ;;; __(optional)__
  ;;; Invalidate a managed key pair given a key pair identifier and a version.
  ;;;
  ;;; This asks the key manager to delete or revoke a key pair or a version of a key pair.
  ;;;
  ;;; Once this function returns, `signature_keypair_from_id` will return that key pair any longer.
  ;;;
  ;;; `kp_version` can be set to a version number, to `version.latest` to invalidate the current version, or to `version.all` to invalidate all versions of a key.
  ;;;
  ;;; The function returns `unsupported_feature` if this operation is not supported by the host, and `key_not_found` if the identifier and version don't match any existing key pair.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_invalidate")
    (param $kp_manager $signature_keypair_manager)
    (param $kp_id (@witx const_pointer u8))
    (param $kp_id_len $size)
    (param $kp_version $version)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Export a signature key pair as the given encoding format.
  ;;;
  ;;; May return `prohibited_operation` if this operation is denied or `unsupported_encoding` if the encoding is not supported.
  ;;;
  ;;; This is an optional import, meaning that the function may not even exist.
  (@interface func (export "signature_keypair_export")
    (param $kp $signature_keypair)
    (param $encoding $keypair_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Get a public key of a signature key pair.
  ;;;
  ;;; The returned object can be used to verify signatures.
  (@interface func (export "signature_keypair_publickey")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Destroys a signature key pair.
  ;;;
  ;;; The host will automatically wipe traces of the secret key from memory.
  ;;;
  ;;; If this is a managed key, the key will not be removed from persistent storage, and can be reconstructed later using the key identifier.
  (@interface func (export "signature_keypair_close")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
  )

  ;;; Import a signature public key.
  ;;;
  ;;; The returned object can be used to verify signatures.
  ;;;
  ;;; The function may return `unsupported_encoding` if importing from the given format is not implemented or incompatible with the key type.
  ;;; It may also return `invalid_key` if the key doesn't appear to match the supplied algorithm.
  (@interface func (export "signature_publickey_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (param $encoding $publickey_encoding)
    (result $error $crypto_errno)
    (result $pk $signature_publickey)
  )

  ;;; Check that a signature public key is valid and in canonical form.
  ;;;
  ;;; This function may perform stricter checks than those made during importation at the expense of additional CPU cycles.
  ;;;
  ;;; The function returns `invalid_key` if the public key didn't pass the checks.
  (@interface func (export "signature_publickey_verify")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Destroys a public key.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "signature_publickey_close")
    (param $pk $signature_publickey)
    (result $error $crypto_errno)
  )

  ;;; Export a signature.
  ;;;
  ;;; This function exports a signature object using the specified encoding.
  ;;;
  ;;; May return `unsupported_encoding` if the signature cannot be encoded into the given format.
  (@interface func (export "signature_export")
    (param $signature $signature)
    (param $encoding $signature_encoding)
    (result $error $crypto_errno)
    (result $encoded $array_output)
  )

  ;;; Create a signature object.
  ;;;
  ;;; This object can be used along with a public key to verify an existing signature.
  ;;;
  ;;; It may return `invalid_signature` if the signature is invalid or incompatible with the specified algorithm, as well as `unsupported_encoding` if the encoding is not compatible with the signature type.
  (@interface func (export "signature_import")
    (param $algorithm string)
    (param $encoding $signature_encoding)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $signature $signature)
  )

  ;;; Create a new state to collect data to compute a signature on.
  ;;;
  ;;; This function allows data to be signed to be supplied in a streaming fashion.
  ;;;
  ;;; The state is not closed and can be used after a signature has been computed, allowing incremental updates by calling `signature_state_update()` again afterwards.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let kp_handle = ctx.signature_keypair_import("Ed25519ph", keypair, KeypairEncoding::Raw)?
  ;;; let state_handle = ctx.signature_state_open(kp_handle)?;
  ;;; ctx.signature_state_update(state_handle, b"message part 1")?;
  ;;; ctx.signature_state_update(state_handle, b"message part 2")?;
  ;;; let sig_handle = ctx.signature_state_sign(state_handle)?;
  ;;; let raw_sig = ctx.signature_export(sig_handle, SignatureEncoding::Raw)?;
  ;;; ```
  (@interface func (export "signature_state_open")
    (param $kp $signature_keypair)
    (result $error $crypto_errno)
    (result $state $signature_state)
  )

  ;;; Absorb data into the signature state.
  ;;;
  ;;; This function may return `unsupported_feature` is the selected algorithm doesn't support incremental updates.
  (@interface func (export "signature_state_update")
    (param $state $signature_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute a signature for all the data collected up to that point.
  ;;;
  ;;; The function can be called multiple times for incremental signing.
  (@interface func (export "signature_state_sign")
    (param $state $signature_state)
    (result $error $crypto_errno)
    (result $signature $array_output)
  )

  ;;; Destroy a signature state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  ;;;
  ;;; Note that closing a signature state doesn't close or invalidate the key pair object, that be reused for further signatures.
  (@interface func (export "signature_state_close")
    (param $state $signature_state)
    (result $error $crypto_errno)
  )

  ;;; Create a new state to collect data to verify a signature on.
  ;;;
  ;;; This is the verification counterpart of `signature_state`.
  ;;;
  ;;; Data can be injected using `signature_verification_state_update()`, and the state is not closed after a verification, allowing incremental verification.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let pk_handle = ctx.signature_publickey_import("ECDSA_P256_SHA256", encoded_pk PublicKeyEncoding::CompressedSec)?;
  ;;; let signature_handle = ctx.signature_import("ECDSA_P256_SHA256", encoded_sig, PublicKeyEncoding::Der)?;
  ;;; let state_handle = ctx.signature_verification_state_open(pk_handle)?;
  ;;; ctx.signature_verification_state_update(state_handle, "message")?;
  ;;; ctx.signature_verification_state_verify(signature_handle)?;
  ;;; ```
  (@interface func (export "signature_verification_state_open")
    (param $kp $signature_publickey)
    (result $error $crypto_errno)
    (result $state $signature_verification_state)
  )

  ;;; Absorb data into the signature verification state.
  ;;;
  ;;; This function may return `unsupported_feature` is the selected algorithm doesn't support incremental updates.
  (@interface func (export "signature_verification_state_update")
    (param $state $signature_verification_state)
    (param $input (@witx const_pointer u8))
    (param $input_len $size)
    (result $error $crypto_errno)
  )

  ;;; Check that the given signature is verifies for the data collected up to that point point.
  ;;;
  ;;; The state is not closed and can absorb more data to allow for incremental verification.
  ;;;
  ;;; The function returns `invalid_signature` if the signature doesn't appear to be valid.  
  (@interface func (export "signature_verification_state_verify")
    (param $state $signature_verification_state)
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature verification state.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  ;;;
  ;;; Note that closing a signature state doesn't close or invalidate the public key object, that be reused for further verifications.
  (@interface func (export "signature_verification_state_close")
    (param $state $signature_verification_state)
    (result $error $crypto_errno)
  )

  ;;; Destroy a signature.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "signature_close")
    (param $signature $signature)
    (result $error $crypto_errno)
  )

  ;;; Return the length of an authentication tag.
  ;;;
  ;;; This function can be used by a guest to allocate the correct buffer size to copy a computed authentication tag.
  (@interface func (export "symmetric_tag_len")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Copy an authentication tag into a guest-allocated buffer.
  ;;;
  ;;; The handle automatically becomes invalid after this operation. Manually closing it is not required.
  ;;;
  ;;; Example usage:
  ;;;
  ;;; ```rust
  ;;; let mut raw_tag = [0u8; 16];
  ;;; ctx.symmetric_tag_pull(raw_tag_handle, &mut raw_tag)?;
  ;;; ```
  ;;;
  ;;; The function returns `overflow` if the supplied buffer is too small to copy the tag.
  (@interface func (export "symmetric_tag_pull")
    (param $symmetric_tag $symmetric_tag)
    (param $buf (@witx pointer u8))
    (param $buf_len $size)
    (result $error $crypto_errno)
  )

  ;;; Verify that a computed authentication tag matches the expected value, in constant-time.
  ;;;
  ;;; The expected tag must be provided as a raw byte string.
  ;;;
  ;;; The function returns `invalid_tag` if the tags don't match.
  (@interface func (export "symmetric_tag_verify")
    (param $symmetric_tag $symmetric_tag)
    (param $expected_raw_tag_ptr (@witx const_pointer u8))
    (param $expected_raw_tag_len $size)
    (result $error $crypto_errno)
  )

  ;;; Destroy an authentication tag.
  ;;;
  ;;; Objects are reference counted. It is safe to close an object immediately after the last function needing it is called.
  (@interface func (export "symmetric_tag_close")
    (param $symmetric_tag $symmetric_tag)
    (result $error $crypto_errno)
  )

  ;;; Generate a new symmetric key for a gigven algorithm.
  ;;;
  ;;; `options` can be `None` to use the default parameters, or an algoritm-specific set of parameters to override.
  ;;;
  ;;; This function may return `unsupported_feature` if key generation is not supported by the host for the chosen algorithm, or `unsupported_algorithm` if the algorithm is not supported by the host.
  (@interface func (export "symmetric_key_generate")
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Import a symmetric key.
  (@interface func (export "symmetric_key_import")
    (param $algorithm string)
    (param $encoded (@witx const_pointer u8))
    (param $encoded_len $size)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; Destroys a symmetric key.
  (@interface func (export "symmetric_key_close")
    (param $symmetric_key $symmetric_key)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Create a context to access a key manager.
  (@interface func (export "symmetric_key_manager_open")
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key_manager)
  )

  ;;; __(optional)__
  ;;; Destroy a key manager.
  (@interface func (export "symmetric_key_manager_close")
    (param $symmetric_key_manager $symmetric_key_manager)
    (result $error $crypto_errno)
  )

  ;;; __(optional)__
  ;;; Return the symmetric key identifier and version, if these are available
  ;;; or `$crypto_errno.unsupported_feature` if not.
  (@interface func (export "symmetric_key_id")
    (param $symmetric_key $symmetric_key)
    (param $symmetric_key_id (@witx pointer u8))
    (param $symmetric_key_id_max_len $size)
    (result $error $crypto_errno)
    (result $symmetric_key_id_len $size)
    (result $version $version)
  )

  ;;; __(optional)__
  ;;; Generate a new managed symmetric key.
  ;;; This function may return `$crypto_errno.unsupported_feature` if key
  ;;; generation is not supported by the host for the chosen algorithm.
  (@interface func (export "symmetric_managed_key_generate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $algorithm string)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; __(optional)__
  ;;; Create a symmetric key using an opaque key identifier.
  ;;; Return `$crypto_errno.unsupported_feature` if this operation is not
  ;;; supported by the host, and crypto_errno.invalid_key if the identifier
  ;;; is invalid.
  ;;; The version can be an actual version number or `$version.latest`.
  (@interface func (export "symmetric_key_from_id")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
    (result $handle $symmetric_key)
  )

  ;;; __(optional)__
  ;;; Invalidate a symmetric key given a key identifier and a version.
  ;;; Return `$crypto_errno.unsupported_feature` if this operation is not
  ;;; supported by the host, and `$crypto_errno.invalid_key` if the identifier
  ;;; is invalid.
  ;;; The version can be a actual version number, as well as
  ;;; `$version.latest` or `$version.all`.
  (@interface func (export "symmetric_key_invalidate")
    (param $symmetric_key_manager $symmetric_key_manager)
    (param $symmetric_key_id (@witx const_pointer u8))
    (param $symmetric_key_id_len $size)
    (param $symmetric_key_version $version)
    (result $error $crypto_errno)
  )

  ;;; Retrieve a parameter from the current state.
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used
  ;;; to get a nonce that as automatically generated.
  (@interface func (export "symmetric_state_open")
    (param $algorithm string)
    (param $key $opt_symmetric_key)
    (param $options $opt_options)
    (result $error $crypto_errno)
    (result $symmetric_state $symmetric_state)
  )

  ;;; Retrieve a parameter from the current state.
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used
  ;;; to get a nonce that as automatically generated.
  (@interface func (export "symmetric_state_options_get")
    (param $handle $symmetric_state)
    (param $name string)
    (param $value (@witx pointer u8))
    (param $value_max_len $size)
    (result $error $crypto_errno)
    (result $value_len $size)
  )

  ;;; Retrieve an integer parameter from the current state.
  ;;; In particular, `symmetric_state_options_get("nonce")` can be used
  ;;; to get a nonce that as automatically generated.
  (@interface func (export "symmetric_state_options_get_u64")
    (param $handle $symmetric_state)
    (param $name string)
    (result $error $crypto_errno)
    (result $value u64)
  )

  ;;; Destroy a symmetric state.
  (@interface func (export "symmetric_state_close")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )

  ;;; Absorb data into the state.
  ;;; This can be data to be hashed for a hash function,
  ;;; or additional data for an AEAD.
  (@interface func (export "symmetric_state_absorb")
    (param $handle $symmetric_state)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
  )

  ;;; Squeeze bytes from the state.
  ;;; This can be the output of a hash function (with limits on
  ;;; the output length), a XOF, a stream cipher or a KDF.
  (@interface func (export "symmetric_state_squeeze")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (result $error $crypto_errno)
  )

  ;;; Compute and return a tag for all the data injected into
  ;;; the state so far. This can be a MAC or a self-contained
  ;;; verification tag for a password hashing function.
  (@interface func (export "symmetric_state_squeeze_tag")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
    (result $symmetric_tag $symmetric_tag)
  )

  ;;; Compute a new key, that can be used to resume a session
  ;;; without storing a nonce.
  (@interface func (export "symmetric_state_squeeze_key")
    (param $handle $symmetric_state)
    (param $raw (@witx pointer u8))
    (param $raw_len $size)
    (result $error $crypto_errno)
  )

  ;;; Return the maximum length of a for the current algorithm.
  (@interface func (export "symmetric_state_max_tag_len")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
    (result $len $size)
  )

  ;;; Encrypt data.
  ;;; With authenticated encryption, the output will include
  ;;; the authentication tag. Therefore, `$out_len` must be
  ;;; at least `symmetric_state_max_tag_len()` byte larger than
  ;;; the input.
  ;;; If `out` and `data` are the same address, encryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_encrypt")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Encrypt data, with a detached tag.
  ;;; If `out` and `data` are the same address, encryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_encrypt_detached")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $symmetric_tag $symmetric_tag)
  )

  ;;; Decrypt data with an attached tag.
  ;;; If `out` and `data` are the same address, decryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_decrypt")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Decrypt data with a detached tag.
  ;;; If `out` and `data` are the same address, decryption may
  ;;; happen in-place.
  (@interface func (export "symmetric_state_decrypt_detached")
    (param $handle $symmetric_state)
    (param $out (@witx pointer u8))
    (param $out_len $size)
    (param $data (@witx const_pointer u8))
    (param $data_len $size)
    (param $raw_tag (@witx const_pointer u8))
    (param $raw_tag_len $size)
    (result $error $crypto_errno)
    (result $actual_out_len $size)
  )

  ;;; Make it impossible to recover the previous state.
  (@interface func (export "symmetric_state_ratchet")
    (param $handle $symmetric_state)
    (result $error $crypto_errno)
  )
)
